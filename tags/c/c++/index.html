<!DOCTYPE html>

<html lang="zh-tw">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="format-detection" content="telephone=no"/>

    <title>gattaca-ngin</title>
    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#FF3DB4">
    <meta name="theme-color" content="#ffffff">

    
    
    
    <link rel="stylesheet" href="https://daichou.github.io/css/main.min.03322cbe6bddfc28e7b17b84bc5446282a510b14b57be3371ba1f68ef1ab9ce8.css"/>

    
    
    

    
    
 
    
    <link rel="alternate" type="application/rss+xml" href="https://daichou.github.io/tags/c/c++/index.xml" title="gattaca-ngin" />
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-161437179-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>
    <body>
        
<nav>
  <header>
    <div class="site-title">
        <a href="/">gattaca-ngin</a>
    </div>  
</header>
  <div class="nav-menu">
  
  <a class="color-link nav-link" href="https://daichou.github.io/index.xml" target="_blank" rel="noopener" type="application/rss+xml">RSS</a>
</div>
<footer class="footer">
	<div class="social-icons">
        

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    
    

    
    
    

    

    

    

    

</div>




	<p><a href="https://github.com/kimcc/hugo-theme-noteworthy" target="_blank" rel="noopener">Noteworthy theme</a></p>
	<p><a href="https://gohugo.io" target="_blank" rel="noopener">Built with Hugo</a></p>

	<script src="https://daichou.github.io/js/main.min.fa5c2b23e07b5d9bfad267a52b4b24fdb053e6fb7524993383594926a3ac270c.js" integrity="sha256-+lwrI+B7XZv60melK0sk/bBT5vt1JJkzg1lJJqOsJww="></script>
</footer>
</nav>
        <div id="content" class="content-container">
        

  <h1>Tagged "C/C&#43;&#43;"</h1>
  
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/note-gdb/">
                    [Note] GDB 一些指令功能速查
                </a>
            </h2>
            <div>
                <p>
                [Note] GDB 一些指令功能速查 前情提要 這篇主要是介紹gdb的一些常用功能，遇到的時候方便google。
常用功能  backtrace breakpoint watchpoint stopwatch dump register dump variable continue and stop disasmmebly return  指令速查  backtrace  bt   breakpoint  b br   watchpoint  watch variable_name or watch variable_address   stopwatch  maint link   dump register  info r   dump variable  print variable_name print &amp;variable_name =&gt; get address print *variable_address =&gt; get address contents info display   continue and stop  c =&gt; continue r= &gt; run stop =&gt; Ctrl+c   disasmmebly  disassemble (func…) link layout asm layout src   return  return (return this stack)     Written with StackEdit.
                </p>
            </div>
            <div class="post-footer">
            <time>March 3, 2017</time>
            </div> 
        </article>
    
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/c99-fast-data-type/">
                    C99 fast data type
                </a>
            </h2>
            <div>
                <p>
                C99 fast data type 這個主題是我在看完Efficient C Tip #13 – use the modulus (%) operator with caution這篇文章發現的C99在stdint.h新規範的一些資料型態，所作的小小理解。
C99 fast data type，為一種針對硬體CPU架構所提出的資料型態。主要有這下列八種型態：
uint_fast8_t 
uint_fast16_t
uint_fast32_t
uint_fast64_t
int_fast8_t 
int_fast16_t
int_fast32_t
int_fast64_t
在C99 7.18.1.3是這樣做定義的：
1 Each of the following types designates an integer type that is usually fastest 219) to operate
with among all integer types that have at least the specified width.
2 The typedef name int_fastN_t designates the fastest signed integer type with a width
                </p>
            </div>
            <div class="post-footer">
            <time>December 6, 2016</time>
            </div> 
        </article>
    
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/compiler-explorercc/">
                    用Compiler Explorer學習C/C&#43;&#43;的效能與實做
                </a>
            </h2>
            <div>
                <p>
                用Compiler Explorer學習C/C++的效能與實做 今天我發現一個網站:compiler explorer，這個網站可以將C和C++即時編譯為組語，而且寒可以選AT&amp;T語法的nasm和INTEL語法的nasm，對於底層學習很有幫助。
支援 這個網站支援ARM、MIPS、X86、AVR等指令集的compiler，支援度甚廣，且網頁本身也開源(使用node.js)，連結:https://github.com/mattgodbolt/gcc-explorer
操作畫面
                </p>
            </div>
            <div class="post-footer">
            <time>August 16, 2016</time>
            </div> 
        </article>
    
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/pwm/">
                    PWM產生方式
                </a>
            </h2>
            <div>
                <p>
                PWM簡述 PWM為Pulse Width Modulation的縮寫，對於只有high和low的數位訊號來說，如何用high,low比率調整出類似類比訊號為PWM的用處，另外大多數馬達也透過PWM來驅動轉速，LED由於只吃固定電壓，所以常用PWM來調整亮度。

duty cycle(占空比)為整個high時間除以週期時間(D = DT/T)。
PWM產生方式 PWM主要又三種方式產生：硬體內建PWM模組、中斷產生、迴圈。
硬體內建PWM模組 MCU內常內建PWM模組，以PIC系列為例，有CCP(Capture/Compare/PWM)模組、Output Compare模組和PWM模組。透過設定timer和暫存去達成PWM輸出。以下以dsPIC30F4013的Output Compare做示範。
#include &lt;xc.h&gt;  // FOSC #pragma config FOSFPR = XT_PLL4 // Oscillator (XT w/PLL 4x) #pragma config FCKSMEN = CSW_FSCM_OFF // Clock Switching and Monitor (Sw Disabled, Mon Disabled)  // FWDT #pragma config FWPSB = WDTPSB_16 // WDT Prescaler B (1:16) #pragma config FWPSA = WDTPSA_512 // WDT Prescaler A (1:512) #pragma config WDT = WDT_OFF // Watchdog Timer (Disabled)  // FBORPOR #pragma config FPWRT = PWRT_64 // POR Timer Value (64ms) #pragma config BODENV = BORV20 // Brown Out Voltage (Reserved) #pragma config BOREN = PBOR_ON // PBOR Enable (Enabled) #pragma config MCLRE = MCLR_EN // Master Clear Enable (Enabled)  // FGS #pragma config GWRP = GWRP_OFF // General Code Segment Write Protect (Disabled) #pragma config GCP = CODE_PROT_OFF // General Segment Code Protection (Disabled)  // FICD #pragma config ICS = ICS_PGD // Comm Channel Select (Use PGC/EMUC and PGD/EMUD)  #define Tcy 10000000 //10MHz oscillator with 4xPLL -&gt; 10&#39;000&#39;000MIPS  //------------------------------------------------------------------------------ // main routine //------------------------------------------------------------------------------ int main(int argc, char** argv) { //------------------------------------------------------------------------------ // IO Plan  TRISA = 0x0000; TRISB = 0x0000; TRISC = 0x0000; TRISD = 0x0000; //RD1,RD2,RD3,RD4 -&gt; PWM OC pin  TRISF = 0x0000; ADPCFG = 0xFFFF; //------------------------------------------------------------------------------ // initialize PWM  //PR2 = 50000; 1:256-&gt; 200 HZ  PR2 = 25000; OC1RS = 1875; OC1CON = 0x0006; //Set PWM mode on OC1,Fault pin disable,Timer2 is source  OC2RS = 1875; OC2CON = 0x0006; //Set PWM mode on OC2,Fault pin disable,Timer2 is source  OC3RS = 1875; OC3CON = 0x0006; //Set PWM mode on OC3,Fault pin disable,Timer2 is source  OC4RS = 1875; OC4CON = 0x0006; //Set PWM mode on OC4,Fault pin disable,Timer2 is source  //IEC0bits.
                </p>
            </div>
            <div class="post-footer">
            <time>July 31, 2016</time>
            </div> 
        </article>
    
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/libpqxx-prepare-statements/">
                    [筆記] libpqxx - prepare statements
                </a>
            </h2>
            <div>
                <p>
                prepare語法是現今SQL主要防止SQL injection的方法(另一種是字串處理)，prepare語法主要是限定SQL query語句中的變數，以防資料庫其他資料遭受破壞等。postgresSQL也有prepare語法。請見：http://www.postgresql.org/docs/9.1/static/sql-prepare.html
而libpqxx中也有prepare method。這個prepare框架一旦被定義後，它會存活於connetion物件存活期間(連線期間)。底下是範例，其中prepare_name爲使用者自定(case sensitive)，之後會用到。
connection C(/*user parameter*/); C.prepare(&#34;prepare_name&#34;,&#34;SELECT NAME FROM TESTTABLE WHERE id = $1&#34;); 再來是傳遞變數進入prepare的框架。
connection C(/*user parameter*/); pqxx::work W(C); C.prepare(&#34;prepare_name&#34;,&#34;SELECT NAME FROM TESTTABLE WHERE id = $1&#34;); pqxx::result r = W.prepared(&#34;prepare_name&#34;)(ID).exec(); W.commit(); 其中傳變數方法還有其他寫法，請見：http://stackoverflow.com/questions/31833322/how-to-prepare-statements-and-bind-parameters-in-postgresql-for-c
prepare方法有時會降低效率，其他細節都在官方paper中。
                </p>
            </div>
            <div class="post-footer">
            <time>May 8, 2016</time>
            </div> 
        </article>
    
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/libpqxx-postgresql-c-library/">
                    libpqxx - postgresql c&#43;&#43; library 基本教學
                </a>
            </h2>
            <div>
                <p>
                簡介  libpqxx是postgrsql 官方所推出的函式庫，基本上包裝得很好，用起來十分簡便。
libpqxx官網：http://pqxx.org/
 linux上安裝方式  請先安裝postgresql，方便起見可安裝php,phppgadmin和apache以利測試。
link:https://wiki.archlinux.org/index.php/PostgreSQL
libray link:http://pqxx.org/download/software/libpqxx/
$ wget http://pqxx.org/download/software/libpqxx/libpqxx-4.0.tar.gz $ tar -zxvf libpqxx-4.0-tar.gz $ cd libpqxx-4.0 $ ./configure $ make $ make install arch linux上安裝方式，libpqxx為Extra package。link:https://www.archlinux.org/packages/extra/i686/libpqxx/
$ sudo pacman -Sy libpqxx 安裝完成後，於postgresql安裝目錄下。
$ cp pg_hba.conf.sample pg_hba.conf 於pg_hba.conf新增
# IPv4 local connections: host all all 127.0.0.1/32 md5 啟動與停止postgresql，基本上使用systemd的linux distro都可用以下方式來處理
$ sudo systemctl start postgresql.service $ sudo systemctl stop postgresql.service  基本用法  libpqxx通常需要透過pqxx::connection來建立連線，接著以transaction物件pqxx::work執行sql操作。以下為基本範例
#include&lt;iostream&gt;#include&lt;pqxx/pqxx&gt;#include&lt;string&gt; using namespace std; using namespace pqxx; int main() { string sql; try{ connection C(&#34;dbname=testdb user=postgres password=pqsswd \ hostaddr=127.
                </p>
            </div>
            <div class="post-footer">
            <time>May 1, 2016</time>
            </div> 
        </article>
    


        
        </div>
        <footer class="footer-mobile">
	<div class="social-icons">
        

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    
    

    
    
    

    

    

    

    

</div>




	<div class="footer-mobile-links">
		<p><a href="https://github.com/kimcc/hugo-theme-noteworthy" target="_blank" rel="noopener">Noteworthy theme</a></p>
		<span class="divider-bar">|</span>
		<p><a href="https://gohugo.io" target="_blank" rel="noopener">Built with Hugo</a></p>
	</div>

	<script src="https://daichou.github.io/js/main.min.fa5c2b23e07b5d9bfad267a52b4b24fdb053e6fb7524993383594926a3ac270c.js" integrity="sha256-+lwrI+B7XZv60melK0sk/bBT5vt1JJkzg1lJJqOsJww="></script>
</footer>
    </body>
</html>