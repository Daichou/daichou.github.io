<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on Daichou&#39;s blog</title>
    <link>https://daichou.github.io/tags/c/c&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on Daichou&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    
	<atom:link href="https://daichou.github.io/tags/c/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Note] GDB 一些指令功能速查</title>
      <link>https://daichou.github.io/posts/note-gdb/</link>
      <pubDate>Fri, 03 Mar 2017 21:09:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/note-gdb/</guid>
      <description>[Note] GDB 一些指令功能速查 前情提要 這篇主要是介紹gdb的一些常用功能，遇到的時候方便google。
常用功能  backtrace breakpoint watchpoint stopwatch dump register dump variable continue and stop disasmmebly return  指令速查  backtrace  bt   breakpoint  b br   watchpoint  watch variable_name or watch variable_address   stopwatch  maint link   dump register  info r   dump variable  print variable_name print &amp;amp;variable_name =&amp;gt; get address print *variable_address =&amp;gt; get address contents info display   continue and stop  c =&amp;gt; continue r= &amp;gt; run stop =&amp;gt; Ctrl+c   disasmmebly  disassemble (func…) link layout asm layout src   return  return (return this stack)     Written with StackEdit.</description>
    </item>
    
    <item>
      <title>C99 fast data type</title>
      <link>https://daichou.github.io/posts/c99-fast-data-type/</link>
      <pubDate>Tue, 06 Dec 2016 20:05:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/c99-fast-data-type/</guid>
      <description>C99 fast data type 這個主題是我在看完Efficient C Tip #13 – use the modulus (%) operator with caution這篇文章發現的C99在stdint.h新規範的一些資料型態，所作的小小理解。
C99 fast data type，為一種針對硬體CPU架構所提出的資料型態。主要有這下列八種型態：
uint_fast8_t 
uint_fast16_t
uint_fast32_t
uint_fast64_t
int_fast8_t 
int_fast16_t
int_fast32_t
int_fast64_t
在C99 7.18.1.3是這樣做定義的：
1 Each of the following types designates an integer type that is usually fastest 219) to operate
with among all integer types that have at least the specified width.
2 The typedef name int_fastN_t designates the fastest signed integer type with a width</description>
    </item>
    
    <item>
      <title>用Compiler Explorer學習C/C&#43;&#43;的效能與實做</title>
      <link>https://daichou.github.io/posts/compiler-explorercc/</link>
      <pubDate>Tue, 16 Aug 2016 02:30:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/compiler-explorercc/</guid>
      <description>用Compiler Explorer學習C/C++的效能與實做 今天我發現一個網站:compiler explorer，這個網站可以將C和C++即時編譯為組語，而且寒可以選AT&amp;amp;T語法的nasm和INTEL語法的nasm，對於底層學習很有幫助。
支援 這個網站支援ARM、MIPS、X86、AVR等指令集的compiler，支援度甚廣，且網頁本身也開源(使用node.js)，連結:https://github.com/mattgodbolt/gcc-explorer
操作畫面</description>
    </item>
    
    <item>
      <title>PWM產生方式</title>
      <link>https://daichou.github.io/posts/pwm/</link>
      <pubDate>Sun, 31 Jul 2016 02:22:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/pwm/</guid>
      <description>PWM簡述 PWM為Pulse Width Modulation的縮寫，對於只有high和low的數位訊號來說，如何用high,low比率調整出類似類比訊號為PWM的用處，另外大多數馬達也透過PWM來驅動轉速，LED由於只吃固定電壓，所以常用PWM來調整亮度。

duty cycle(占空比)為整個high時間除以週期時間(D = DT/T)。
PWM產生方式 PWM主要又三種方式產生：硬體內建PWM模組、中斷產生、迴圈。
硬體內建PWM模組 MCU內常內建PWM模組，以PIC系列為例，有CCP(Capture/Compare/PWM)模組、Output Compare模組和PWM模組。透過設定timer和暫存去達成PWM輸出。以下以dsPIC30F4013的Output Compare做示範。
#include &amp;lt;xc.h&amp;gt;  // FOSC #pragma config FOSFPR = XT_PLL4 // Oscillator (XT w/PLL 4x) #pragma config FCKSMEN = CSW_FSCM_OFF // Clock Switching and Monitor (Sw Disabled, Mon Disabled)  // FWDT #pragma config FWPSB = WDTPSB_16 // WDT Prescaler B (1:16) #pragma config FWPSA = WDTPSA_512 // WDT Prescaler A (1:512) #pragma config WDT = WDT_OFF // Watchdog Timer (Disabled)  // FBORPOR #pragma config FPWRT = PWRT_64 // POR Timer Value (64ms) #pragma config BODENV = BORV20 // Brown Out Voltage (Reserved) #pragma config BOREN = PBOR_ON // PBOR Enable (Enabled) #pragma config MCLRE = MCLR_EN // Master Clear Enable (Enabled)  // FGS #pragma config GWRP = GWRP_OFF // General Code Segment Write Protect (Disabled) #pragma config GCP = CODE_PROT_OFF // General Segment Code Protection (Disabled)  // FICD #pragma config ICS = ICS_PGD // Comm Channel Select (Use PGC/EMUC and PGD/EMUD)  #define Tcy 10000000 //10MHz oscillator with 4xPLL -&amp;gt; 10&amp;#39;000&amp;#39;000MIPS  //------------------------------------------------------------------------------ // main routine //------------------------------------------------------------------------------ int main(int argc, char** argv) { //------------------------------------------------------------------------------ // IO Plan  TRISA = 0x0000; TRISB = 0x0000; TRISC = 0x0000; TRISD = 0x0000; //RD1,RD2,RD3,RD4 -&amp;gt; PWM OC pin  TRISF = 0x0000; ADPCFG = 0xFFFF; //------------------------------------------------------------------------------ // initialize PWM  //PR2 = 50000; 1:256-&amp;gt; 200 HZ  PR2 = 25000; OC1RS = 1875; OC1CON = 0x0006; //Set PWM mode on OC1,Fault pin disable,Timer2 is source  OC2RS = 1875; OC2CON = 0x0006; //Set PWM mode on OC2,Fault pin disable,Timer2 is source  OC3RS = 1875; OC3CON = 0x0006; //Set PWM mode on OC3,Fault pin disable,Timer2 is source  OC4RS = 1875; OC4CON = 0x0006; //Set PWM mode on OC4,Fault pin disable,Timer2 is source  //IEC0bits.</description>
    </item>
    
    <item>
      <title>[筆記] libpqxx - prepare statements</title>
      <link>https://daichou.github.io/posts/libpqxx-prepare-statements/</link>
      <pubDate>Sun, 08 May 2016 09:16:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/libpqxx-prepare-statements/</guid>
      <description>prepare語法是現今SQL主要防止SQL injection的方法(另一種是字串處理)，prepare語法主要是限定SQL query語句中的變數，以防資料庫其他資料遭受破壞等。postgresSQL也有prepare語法。請見：http://www.postgresql.org/docs/9.1/static/sql-prepare.html
而libpqxx中也有prepare method。這個prepare框架一旦被定義後，它會存活於connetion物件存活期間(連線期間)。底下是範例，其中prepare_name爲使用者自定(case sensitive)，之後會用到。
connection C(/*user parameter*/); C.prepare(&amp;#34;prepare_name&amp;#34;,&amp;#34;SELECT NAME FROM TESTTABLE WHERE id = $1&amp;#34;); 再來是傳遞變數進入prepare的框架。
connection C(/*user parameter*/); pqxx::work W(C); C.prepare(&amp;#34;prepare_name&amp;#34;,&amp;#34;SELECT NAME FROM TESTTABLE WHERE id = $1&amp;#34;); pqxx::result r = W.prepared(&amp;#34;prepare_name&amp;#34;)(ID).exec(); W.commit(); 其中傳變數方法還有其他寫法，請見：http://stackoverflow.com/questions/31833322/how-to-prepare-statements-and-bind-parameters-in-postgresql-for-c
prepare方法有時會降低效率，其他細節都在官方paper中。</description>
    </item>
    
    <item>
      <title>libpqxx - postgresql c&#43;&#43; library 基本教學</title>
      <link>https://daichou.github.io/posts/libpqxx-postgresql-c-library/</link>
      <pubDate>Sun, 01 May 2016 02:33:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/libpqxx-postgresql-c-library/</guid>
      <description>簡介  libpqxx是postgrsql 官方所推出的函式庫，基本上包裝得很好，用起來十分簡便。
libpqxx官網：http://pqxx.org/
 linux上安裝方式  請先安裝postgresql，方便起見可安裝php,phppgadmin和apache以利測試。
link:https://wiki.archlinux.org/index.php/PostgreSQL
libray link:http://pqxx.org/download/software/libpqxx/
$ wget http://pqxx.org/download/software/libpqxx/libpqxx-4.0.tar.gz $ tar -zxvf libpqxx-4.0-tar.gz $ cd libpqxx-4.0 $ ./configure $ make $ make install arch linux上安裝方式，libpqxx為Extra package。
link:https://www.archlinux.org/packages/extra/i686/libpqxx/
$ sudo pacman -Sy libpqxx 安裝完成後，於postgresql安裝目錄下。
$ cp pg_hba.conf.sample pg_hba.conf 於pg_hba.conf新增
# IPv4 local connections: host all all 127.0.0.1/32 md5 啟動與停止postgresql，基本上使用systemd的linux distro都可用以下方式來處理
$ sudo systemctl start postgresql.service $ sudo systemctl stop postgresql.service  基本用法  libpqxx通常需要透過pqxx::connection來建立連線，接著以transaction物件pqxx::work執行sql操作。以下為基本範例</description>
    </item>
    
  </channel>
</rss>