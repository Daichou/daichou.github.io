<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on gattaca-ngin</title>
    <link>https://daichou.github.io/tags/c/c&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on gattaca-ngin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    
	<atom:link href="https://daichou.github.io/tags/c/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Note] GDB 一些指令功能速查</title>
      <link>https://daichou.github.io/posts/note-gdb/</link>
      <pubDate>Fri, 03 Mar 2017 21:09:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/note-gdb/</guid>
      <description>[Note] GDB 一些指令功能速查 前情提要 這篇主要是介紹gdb的一些常用功能，遇到的時候方便google。
常用功能  backtrace breakpoint watchpoint stopwatch dump register dump variable continue and stop disasmmebly return  指令速查  backtrace  bt   breakpoint  b br   watchpoint  watch variable_name or watch variable_address   stopwatch  maint link   dump register  info r   dump variable  print variable_name print &amp;amp;variable_name =&amp;gt; get address print *variable_address =&amp;gt; get address contents info display   continue and stop  c =&amp;gt; continue r= &amp;gt; run stop =&amp;gt; Ctrl+c   disasmmebly  disassemble (func…) link layout asm layout src   return  return (return this stack)     Written with StackEdit.</description>
    </item>
    
    <item>
      <title>C99 fast data type</title>
      <link>https://daichou.github.io/posts/c99-fast-data-type/</link>
      <pubDate>Tue, 06 Dec 2016 20:05:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/c99-fast-data-type/</guid>
      <description>C99 fast data type 這個主題是我在看完Efficient C Tip #13 – use the modulus (%) operator with caution這篇文章發現的C99在stdint.h新規範的一些資料型態，所作的小小理解。
C99 fast data type，為一種針對硬體CPU架構所提出的資料型態。主要有這下列八種型態：
uint_fast8_t 
uint_fast16_t
uint_fast32_t
uint_fast64_t
int_fast8_t 
int_fast16_t
int_fast32_t
int_fast64_t
在C99 7.18.1.3是這樣做定義的：
1 Each of the following types designates an integer type that is usually fastest 219) to operate
with among all integer types that have at least the specified width.
2 The typedef name int_fastN_t designates the fastest signed integer type with a width</description>
    </item>
    
    <item>
      <title>用Compiler Explorer學習C/C&#43;&#43;的效能與實做</title>
      <link>https://daichou.github.io/posts/compiler-explorercc/</link>
      <pubDate>Tue, 16 Aug 2016 02:30:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/compiler-explorercc/</guid>
      <description>用Compiler Explorer學習C/C++的效能與實做 今天我發現一個網站:compiler explorer，這個網站可以將C和C++即時編譯為組語，而且寒可以選AT&amp;amp;T語法的nasm和INTEL語法的nasm，對於底層學習很有幫助。
支援 這個網站支援ARM、MIPS、X86、AVR等指令集的compiler，支援度甚廣，且網頁本身也開源(使用node.js)，連結:https://github.com/mattgodbolt/gcc-explorer
操作畫面</description>
    </item>
    
    <item>
      <title>PWM產生方式</title>
      <link>https://daichou.github.io/posts/pwm/</link>
      <pubDate>Sun, 31 Jul 2016 02:22:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/pwm/</guid>
      <description>PWM簡述 PWM為Pulse Width Modulation的縮寫，對於只有high和low的數位訊號來說，如何用high,low比率調整出類似類比訊號為PWM的用處，另外大多數馬達也透過PWM來驅動轉速，LED由於只吃固定電壓，所以常用PWM來調整亮度。

duty cycle(占空比)為整個high時間除以週期時間(D = DT/T)。
PWM產生方式 PWM主要又三種方式產生：硬體內建PWM模組、中斷產生、迴圈。
硬體內建PWM模組 MCU內常內建PWM模組，以PIC系列為例，有CCP(Capture/Compare/PWM)模組、Output Compare模組和PWM模組。透過設定timer和暫存去達成PWM輸出。以下以dsPIC30F4013的Output Compare做示範。
由於每個MCU的PWM實際細節都不一樣，所以讀者請自行閱讀datasheet來應用硬體內建的PWM。
dsPIC30F系列的Output Compare PWM模組要應用時須將OCxCON 暫存器中的OCM設為&amp;rsquo;110&#39;或&amp;rsquo;111&amp;rsquo;。設定順序為:
1.設定PRy(Period register)表示PWM的週期。
2.再來設定OCxRS暫存器表示duty cycle。
3.設定OCM。
4.設定timer，並開啟timer。
PWM 週期 ＝ [(PRy+1)]*Tcy*(TMRx presclaer value)。 (Tcy為振盪器頻率*PLL/4)
PWM 頻率為週期倒數。
詳細設定在http://ww1.microchip.com/downloads/en/DeviceDoc/70157C.pdf中有詳細描述。
中斷產生PWM 利用Timer中斷來切換PWM進入duty cycle，有兩種方法。
一、用一個或兩個timer，先輸出high，計算PWM在high所需時間，設定好Timer 週期(中斷條件)，當Timer發生中斷，將輸出切為low，並在計算PWM在low所需時間，同樣設定好Timer週期，當Timer發生中斷回到一開始重頭來過。也可用兩個Timer一個設為high所需時間，一個為period，當high的timer 中斷發生，關閉其中斷與timer，並將輸出設為low，等待period 的Timer發生中斷，在開啟high 的timer中斷。
二、用一個timer中斷，當其中斷將counter加一，一旦couner的值大於duty cycle則切為low，當counter的值大於period則歸零。以下為範例(使用PIC18F452)。
此方法缺點為PWM頻率難以調整，不過對於本身PWM模組缺乏或過少之MCU，此法十分有效。
迴圈產生PWM 以迴圈直接產生PWM，可以用一個counter當作現在情況，當迴圈執行次數超過duty cycle的值時，調整high low，這方法十分簡單，但如果要有準確的頻率需要將程式編成組語計算其所需時間，並用NOP指令挑整週期。這方法會佔走整個CPU，十分無效率，但其可以結合輪詢等固定時間需要執行的功能，對於低階，簡單的系統有其應用空間。</description>
    </item>
    
    <item>
      <title>[筆記] libpqxx - prepare statements</title>
      <link>https://daichou.github.io/posts/libpqxx-prepare-statements/</link>
      <pubDate>Sun, 08 May 2016 09:16:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/libpqxx-prepare-statements/</guid>
      <description>prepare語法是現今SQL主要防止SQL injection的方法(另一種是字串處理)，prepare語法主要是限定SQL query語句中的變數，以防資料庫其他資料遭受破壞等。postgresSQL也有prepare語法。請見：http://www.postgresql.org/docs/9.1/static/sql-prepare.html
而libpqxx中也有prepare method。這個prepare框架一旦被定義後，它會存活於connetion物件存活期間(連線期間)。底下是範例，其中prepare_name爲使用者自定(case sensitive)，之後會用到。
再來是傳遞變數進入prepare的框架。
其中傳變數方法還有其他寫法，請見：http://stackoverflow.com/questions/31833322/how-to-prepare-statements-and-bind-parameters-in-postgresql-for-c
prepare方法有時會降低效率，其他細節都在官方paper中。</description>
    </item>
    
    <item>
      <title>libpqxx - postgresql c&#43;&#43; library 基本教學</title>
      <link>https://daichou.github.io/posts/libpqxx-postgresql-c-library/</link>
      <pubDate>Sun, 01 May 2016 02:33:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/libpqxx-postgresql-c-library/</guid>
      <description>簡介  libpqxx是postgrsql 官方所推出的函式庫，基本上包裝得很好，用起來十分簡便。
libpqxx官網：http://pqxx.org/
 linux上安裝方式  請先安裝postgresql，方便起見可安裝php,phppgadmin和apache以利測試。
link:https://wiki.archlinux.org/index.php/PostgreSQL
libray link:http://pqxx.org/download/software/libpqxx/
arch linux上安裝方式，libpqxx為Extra package。link:https://www.archlinux.org/packages/extra/i686/libpqxx/
安裝完成後，於postgresql安裝目錄下。
於pg_hba.conf新增
啟動與停止postgresql，基本上使用systemd的linux distro都可用以下方式來處理
 基本用法  libpqxx通常需要透過pqxx::connection來建立連線，接著以transaction物件pqxx::work執行sql操作。以下為基本範例
這個範例使用了三種parse資料的方法，分別是使用pqxx::tuple的方式、使用內建iterator的方式與使用類似C++ STL map的key-value方式。
編譯方式：
參考資料:http://www.yiibai.com/html/postgresql/2013/080894.html</description>
    </item>
    
  </channel>
</rss>