<!DOCTYPE html>

<html lang="zh-tw">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="format-detection" content="telephone=no"/>

    <title>gattaca-ngin</title>
    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#FF3DB4">
    <meta name="theme-color" content="#ffffff">

    
    
    
    <link rel="stylesheet" href="https://daichou.github.io/css/main.min.03322cbe6bddfc28e7b17b84bc5446282a510b14b57be3371ba1f68ef1ab9ce8.css"/>

    
    
    

    
    
 
    
    <link rel="alternate" type="application/rss+xml" href="https://daichou.github.io/tags/hardware/index.xml" title="gattaca-ngin" />
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-161437179-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>
    <body>
        
<nav>
  <header>
    <div class="site-title">
        <a href="/">gattaca-ngin</a>
    </div>  
</header>
  <div class="nav-menu">
  
  <a class="color-link nav-link" href="https://daichou.github.io/index.xml" target="_blank" rel="noopener" type="application/rss+xml">RSS</a>
</div>
<footer class="footer">
	<div class="social-icons">
        

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    
    

    
    
    

    

    

    

    

</div>




	<p><a href="https://github.com/kimcc/hugo-theme-noteworthy" target="_blank" rel="noopener">Noteworthy theme</a></p>
	<p><a href="https://gohugo.io" target="_blank" rel="noopener">Built with Hugo</a></p>

	<script src="https://daichou.github.io/js/main.min.fa5c2b23e07b5d9bfad267a52b4b24fdb053e6fb7524993383594926a3ac270c.js" integrity="sha256-+lwrI+B7XZv60melK0sk/bBT5vt1JJkzg1lJJqOsJww="></script>
</footer>
</nav>
        <div id="content" class="content-container">
        

  <h1>Tagged "hardware"</h1>
  
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/i2c-microchip-plib/">
                    I2C 使用Microchip plib
                </a>
            </h2>
            <div>
                <p>
                I2C 使用Microchip plib 本篇以dsPIC30F為主。
plib 安裝 到Legacy PIC24 MCU &amp; dsPIC DSC Peripheral Library下載最新的plib，然後她會要求將plib安裝到你電腦中xc16 complier的資料夾下(linux在”/opt/microchip/xc16”下)。
函式概覽 安裝後文件會在xc16 complier的docs/periph_libs下。
其中plib提供以下函式。
 AckI2C
CloseI2C
ConfigIntI2C
DataRdyI2C
IdleI2C
MastergetsI2C
MasterputsI2C
MasterReadI2C
MasterWriteI2C
NotAckI2C
OpenI2C
RestartI2C
SlavegetsI2C
SlaveputsI2C
SlaveReadI2C
SlaveWriteI2C
StartI2C
StopI2C
 還有一些MARCO
 EnableIntMI2C
DiableIntMI2C
SetPriorityIntMI2C
EnableIntSI2C
DisableIntSI2C
SetPriorityIntSI2C
 這份文件16 bit language tools第191頁開始有詳述這些函式的介面。所以本文主要會面向如何運用這些函式達成master與slave溝通。
I2C (dsPIC30F as Master with 7bit address) reception 以下圖片來自於http://ww1.microchip.com/downloads/en/DeviceDoc/70046E.pdf

對應到plib的流程為。(以下為我在i2cdevlib中所新增的片段，為一次讀多個bytes)。
請先透過ConfigIntI2C和OpenI2C設定好硬體參數。
值得注意的是在dsPIC30F manual中第5步驟。要透過StartI2C再次產生start condition。而讀入多個data bytes可用MastergetsI2C函式。
transmission transmission只要全部都由Master端給資料即可。
                </p>
            </div>
            <div class="post-footer">
            <time>April 29, 2017</time>
            </div> 
        </article>
    
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/l3g4200-gyroscope/">
                    L3G4200 gyroscope使用筆記
                </a>
            </h2>
            <div>
                <p>
                L3G4200 gyroscope使用筆記 特性與參數  用途：量測姿態 精度：250/500/2000 dps (degree per second) 輸出資料：為angular rate(角速度) ，16bit 原始感應器電壓(僅有晶片)：2.4V ~3.6V 模組(GY50)電壓：3~5V 其他特色：有內建high pass filter和low pass filter可供程式選擇，還有中斷信號選擇 通信方式：I2C/SPIs 晶片datasheet:連結在此 模組(GY50)購買網頁：連結在此  用此模組量測當前姿態方式 軟體部份 Ardunio先安裝wire library和L3G4200D
用這個網站上的code和library即可。
角速度轉成角度 由於該感測器輸出為角速度(離散資料)，所以我們須將角速度做離散積分得到角度。
 角度 ＝ 初始角度 + (角速度*取樣時間的總和)
 下圖為利用QT自製的視覺化工具。其中若要得到角度責須得到線與0軸的面積。

下圖為L3G4200 datasheet p.10 一小部份，其中Sensitivity代表精度，以FS=200dps為例，代表從感測器輸出的數字1代表8.75mdps，如果輸出為兩千時，當前角速度為2000*8.75/1000000dps = 0.0175 dps。

應用限制與誤差處理 由於是作離散積分所以會有誤差，最好使用濾波器(有內建)。
另外由於它需要一直取樣，對Master CPU來說是很大的負擔。
 Written with StackEdit.
 
                </p>
            </div>
            <div class="post-footer">
            <time>February 18, 2017</time>
            </div> 
        </article>
    
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/notemicrocontroller/">
                    [Note]Microcontroller的排程方式
                </a>
            </h2>
            <div>
                <p>
                [Note]Microcontroller的排程方式 這篇為我看完Microchip Technology 20024 FRM4 - Interrupt and Task Scheduling - No RTOS Required後所作的筆記。
Race condition與Synchronization Race condition的觀念在恐龍書已經說很多了，所以就不提了。而Synchronization部份，Microcontroller常用interupt disabling和spin lock來做處理，而用到sempahore的部份也是有。另外值得注意的一點是，由於MCU同時有許多peripheral component(Timer,ADC,SPI,UART&hellip;)再運作，這些元件也會改變SFR(special function register)的值，所以建算你的程式是但執行序，仍可能會有race consition發生，例如：在PIC的 16 bit timer中，他是分成兩個register控制timer的值(TMR1L,TMR1H)，也就是說你要更動timer的值時，需要大於兩個cycle，才可辦到，但是如果在存取值的時候你的timer仍在運作，則可能發生，不合理的狀況。比方說你想要讀取TMR1的值(TMR1H + TMR1L)，原本TMR1H = 0x00,TMR1L = 0xFF，第一部份，你讀到了TMR1H的值為0x00，但在第二部份時你要讀TMR1L的時候，因為timer仍在計時，經過一個cycle，TMR1L的值已經加1並進位到TMR1H，所以TMR1L的值現在為0x00，你讀到的值就是0x00，在這個case中，你預期你會得到(0x00,0xFF)，但你實際上拿到(0x00,0x00)，這是在MCU常有的情況。避免的方法為暫停timer然後再去取值。
 Review interrupt
在MCU中硬體發生的中斷會已硬體的context switch實做，也就是她會將當前的core register複製一份到shadow register儲存，保留狀態，當離開ISR後，CPU會將shadow register載回core register中。
在interupt中，對於跨ISR與main line的變數，可以考慮使用Volatile修飾字(一個資源有多個process使用時，透過這個修飾字可以告訴編譯器，不要對這個值做值域判斷優化)，以免編譯器編出你無法預期的行為。
interrupt在context switch時會有所謂的interrupt latency(在IVT中尋找對應的interrupt vector+context switch+當前指令的完成(例如說MUL))，這是MCU的效能指標之一，不過對於多層的interrupt，在第二層以後失去了硬體context swtich的優化，所以速度會慢很多。
Jitter injection為main line在被中斷後所暫停執行的時間，通常要盡量讓Jitter 愈小愈好。
interupt priority:MCU中的interrupt有priority，規範誰可以中斷誰，例如說PIC18F系列有兩個level，dsPIC30F系列有八個level，此外MCU中透過interrupt 在IVT的順序，有所謂的natural order priority，來處理相同level intertupt同時發生的問題。另外，ISR裡可以包裹多個interrupt handler，這部份一樣是透過IVT先後和priority還有發生時間決定進入點。(其他:可重入程序)。
一些ISR設計的注意細節:
1.盡量ISR短，減少jitter
2.避免無限的等待
3.盡量避免ISR與mainline使用相同的全域變數(有的話記的要加volatile)
Review scheduler(非Real time)與相關技術 有cooperative與preemptive兩大類，恐龍書有詳盡描述。此外還有兼容兩種特性的(hybird)。
常見排程方式與技術有：
                </p>
            </div>
            <div class="post-footer">
            <time>December 7, 2016</time>
            </div> 
        </article>
    
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/ardunio-atmega2560-nrf24l01/">
                    使用Ardunio Atmega2560 連接 nRF24L01&#43;
                </a>
            </h2>
            <div>
                <p>
                使用Ardunio Atmega2560 連接 nRF24L01+ 關於library 目前主流有https://github.com/maniacbug/RF24與https://github.com/TMRh20/RF24這兩個。
其中TMRh20大大做的這個還可支援linux(Raspberry pi)，支援度較廣。不過本篇文章選用maniacbug大大的library。
mega2560連接nRF24L01 以下是nRF24L01 模組的照片與pinout。

從左上開始，右下結束。
         1.GND 2.VDD(3.6V以下)   3.CE 4.CSN   5.SCLK 6.MOSI   7.MISO 8.IRQ    Mega2560部份，我們不需要接IRQ，因為library沒有實做，讀者有興趣可以修改library中關於nRF24L01一個名叫config的暫存器，將mask中斷的部份歸零。
Mega2560的部份需要其上頭內建的SPI BUS，才能使用這個函式庫(TMRh20的library有提供Software SPI應用)。以下是Mega2560的SPI接腳對應。

SCK要接nRF24L01的SCLK，MOSI接MOSI，MISO接MISO，CE和CSN可自行定義腳位。
程式碼部份直接利用官往提供的example來做測試。
http://maniacbug.github.io/RF24/GettingStarted_8pde-example.html
原始碼中RF24物件建構子這行
RF24 radio(9,10); 9表示CE接腳，10表示CSN接腳。
程式運行時可以開啟Serial port monitor來觀察其運作，其中他在radio.printDetails();部份印出的細節可以多留意，尤其是收發兩端的address，在TX_ADDR那項兩邊要不同。接下來就可開心的看著她發送了。
連不上的一些解法 地址錯誤 兩邊的地址要可對到，一邊RX_ADDR要為另一邊TX_ADDR，這樣才可收到。
雜訊 有些nRF24L01模組的電源供應沒有電容濾波，可以自行用電容跨接GND和VCC兩端，建議選擇10uF到50uF的電容，另外模組的GND要和Ardunio的GND共地(從Ardunio直接拉GND是好選擇)。
傳輸速率過快 example預設為2Mbps，可自行降為1Mbps，有機會收到較佳的訊號。
                </p>
            </div>
            <div class="post-footer">
            <time>August 5, 2016</time>
            </div> 
        </article>
    
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/pwm/">
                    PWM產生方式
                </a>
            </h2>
            <div>
                <p>
                PWM簡述 PWM為Pulse Width Modulation的縮寫，對於只有high和low的數位訊號來說，如何用high,low比率調整出類似類比訊號為PWM的用處，另外大多數馬達也透過PWM來驅動轉速，LED由於只吃固定電壓，所以常用PWM來調整亮度。

duty cycle(占空比)為整個high時間除以週期時間(D = DT/T)。
PWM產生方式 PWM主要又三種方式產生：硬體內建PWM模組、中斷產生、迴圈。
硬體內建PWM模組 MCU內常內建PWM模組，以PIC系列為例，有CCP(Capture/Compare/PWM)模組、Output Compare模組和PWM模組。透過設定timer和暫存去達成PWM輸出。以下以dsPIC30F4013的Output Compare做示範。
#include &lt;xc.h&gt;  // FOSC #pragma config FOSFPR = XT_PLL4 // Oscillator (XT w/PLL 4x) #pragma config FCKSMEN = CSW_FSCM_OFF // Clock Switching and Monitor (Sw Disabled, Mon Disabled)  // FWDT #pragma config FWPSB = WDTPSB_16 // WDT Prescaler B (1:16) #pragma config FWPSA = WDTPSA_512 // WDT Prescaler A (1:512) #pragma config WDT = WDT_OFF // Watchdog Timer (Disabled)  // FBORPOR #pragma config FPWRT = PWRT_64 // POR Timer Value (64ms) #pragma config BODENV = BORV20 // Brown Out Voltage (Reserved) #pragma config BOREN = PBOR_ON // PBOR Enable (Enabled) #pragma config MCLRE = MCLR_EN // Master Clear Enable (Enabled)  // FGS #pragma config GWRP = GWRP_OFF // General Code Segment Write Protect (Disabled) #pragma config GCP = CODE_PROT_OFF // General Segment Code Protection (Disabled)  // FICD #pragma config ICS = ICS_PGD // Comm Channel Select (Use PGC/EMUC and PGD/EMUD)  #define Tcy 10000000 //10MHz oscillator with 4xPLL -&gt; 10&#39;000&#39;000MIPS  //------------------------------------------------------------------------------ // main routine //------------------------------------------------------------------------------ int main(int argc, char** argv) { //------------------------------------------------------------------------------ // IO Plan  TRISA = 0x0000; TRISB = 0x0000; TRISC = 0x0000; TRISD = 0x0000; //RD1,RD2,RD3,RD4 -&gt; PWM OC pin  TRISF = 0x0000; ADPCFG = 0xFFFF; //------------------------------------------------------------------------------ // initialize PWM  //PR2 = 50000; 1:256-&gt; 200 HZ  PR2 = 25000; OC1RS = 1875; OC1CON = 0x0006; //Set PWM mode on OC1,Fault pin disable,Timer2 is source  OC2RS = 1875; OC2CON = 0x0006; //Set PWM mode on OC2,Fault pin disable,Timer2 is source  OC3RS = 1875; OC3CON = 0x0006; //Set PWM mode on OC3,Fault pin disable,Timer2 is source  OC4RS = 1875; OC4CON = 0x0006; //Set PWM mode on OC4,Fault pin disable,Timer2 is source  //IEC0bits.
                </p>
            </div>
            <div class="post-footer">
            <time>July 31, 2016</time>
            </div> 
        </article>
    
  
    
    <article>
            <h2>
                <a href="https://daichou.github.io/posts/maker/">
                    Maker常用開發板
                </a>
            </h2>
            <div>
                <p>
                對於Maker來說，選擇適合的開發板可以加速make的時間。本文會依照難度特色來做分類。
入門款
** Ardunio系列：**
 基本款(Entry level):Ardunio UNO,Ardunio 101,Ardunio PRO  &gt;&raquo; 特色：pin腳少(少於20隻)，PWM port少(不多於6隻)，Analog輸入腳位少(少於6)。
&gt;&raquo; 適合入門玩家學習操作I/O(DigitalWrtie),PWM(AnalogWrite),ADC(analogRead)。適合小專案與空間較小之專案。
 進階板(Enhanced feature):Ardunio MEGA,Ardunio ZERO,Ardunio DUE  &gt;&raquo; Ardunio MEGA腳位很多，PWM腳多達15隻，對於需要大量馬達或servo的專案來說十分適合，而且其UART多達四組，還有一組SPI和一組I2C可方便擴充。
&gt;&raquo; Ardunio ZERO是小型低電壓板Ardunio。
&gt;&raquo; Ardunio DUE 是ARM-based的Ardunio，腳位很多，同時還有兩個DAC，和USB-OTG，為MEGA板所沒有的。
 IOT板：Ardunio YUN  &gt;&raquo;Ardunio YUN是一塊同時擁有MCU(Ardunio)和SOC(OS為linux)的開發板，基本連網功能透過linux部份，其餘操作在Ardunio部份上，可支援wifi(IEEE 802.11b/g/n)和ethernet(IEEE 802.11b/g/n)，想當然爾，當然是一塊面向物連網的開發板。
 其他module  很多，去找吧，我把他們全都放在那了。對於入門者來說，最重要的是有library和API支援，不然自己看datasheet來刻是很困難的。
 其他類Ardunio開發板  這裏指得是支援Ardunio語法(library)的開發板，常見的如Picdunio,linkit Smart 7688和linkit 7688 DUO系列等。
進階款
** Raspberry Pi**
 Pi 1,Pi 2 Pi3 , Pi zero:  基本上都是使用Broadcom的單板電腦，都是ARM以處理器為核心，當然ARM系列的優點都有(如省電)，支援USB、ethernet、RCA、I2S、SD卡、相機模組。
作業系統有Raspbian(Debian系，論壇資源最多，問題易找到解答)、Arch Linux Arm(Arch linux十分輕量，而且十分先進，其套件管理佳，但難度叫高)、OpenELEC、Pidora(Fedora)等。
                </p>
            </div>
            <div class="post-footer">
            <time>May 1, 2016</time>
            </div> 
        </article>
    


        
        </div>
        <footer class="footer-mobile">
	<div class="social-icons">
        

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    
    

    
    
    

    

    

    

    

</div>




	<div class="footer-mobile-links">
		<p><a href="https://github.com/kimcc/hugo-theme-noteworthy" target="_blank" rel="noopener">Noteworthy theme</a></p>
		<span class="divider-bar">|</span>
		<p><a href="https://gohugo.io" target="_blank" rel="noopener">Built with Hugo</a></p>
	</div>

	<script src="https://daichou.github.io/js/main.min.fa5c2b23e07b5d9bfad267a52b4b24fdb053e6fb7524993383594926a3ac270c.js" integrity="sha256-+lwrI+B7XZv60melK0sk/bBT5vt1JJkzg1lJJqOsJww="></script>
</footer>
    </body>
</html>