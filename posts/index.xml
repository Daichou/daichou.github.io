<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Daichou&#39;s blog</title>
    <link>https://daichou.github.io/posts/</link>
    <description>Recent content in Posts on Daichou&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Sun, 22 Mar 2020 02:38:00 -0700</lastBuildDate>
    
	<atom:link href="https://daichou.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用Vivado Xilinx AXI verification IP進行AXI ip開發驗證</title>
      <link>https://daichou.github.io/posts/vivado-xilinx-axi-verification-ipaxi-ip/</link>
      <pubDate>Sun, 22 Mar 2020 02:38:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/vivado-xilinx-axi-verification-ipaxi-ip/</guid>
      <description>Xilinx AXI Verification IP tutorial 前情提要 一般來說開發Xilinx FPGA上的AXI master/slave ip都是透過C/C++ 轉成HLS或是直接撰寫Verilog。透過C/C++ 轉成的HLS可以自己寫簡單的C/C++ 程式作為testbench，驗證結果可以直接看C/C++ testbench的結果而定，Verilog細節、AXI操作等問題Vivado HLS會幫你完全處理(如果這些部份出現問題，你也沒輒了)。但是透過Verilog直接寫成的IP，通常需要CPU還有記憶體界面(eg. mig)之類的進行全系統測試，而獲取波形等資訊需要透過合成ILA在板子上實際測試。這流程十分繁瑣，合成ILA會浪費大量syntesis和implementation時間，而且可以debug的的訊號數量受限於晶片上的block ram以及LUT數量。然而很多人忽略了Xilinx其實提供了AXI verification IP，可以簡單快速撰寫testbench直接進行behavior simulation，這對於縮短演算法邏輯開發的時間有益。
本文主要以 CPU &amp;lt;-&amp;gt; AXI slave &amp;lt;=&amp;gt; AXI master &amp;lt;-&amp;gt; memory此模式為主。
完整文件請看AXI Verification IP v1.0。
AXI Verification IP 簡介 Xilinx AXI Verification IP主要提供的功能為:
  產生AXI master command與資料(可自訂) 產生AXI slave進行資料讀取與回覆(也可以模擬mig記憶體界面) 檢查AXI protocol  而Xilinx AXI Verification IP (VIP)主要有三種模式：
  作為AXI master
  用來測試AXI slave ip
  作為AXI slave</description>
    </item>
    
    <item>
      <title>Verilog Diagram generator</title>
      <link>https://daichou.github.io/posts/verilog-diagram-generator/</link>
      <pubDate>Fri, 06 Mar 2020 18:25:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/verilog-diagram-generator/</guid>
      <description>Verilog Diagram generator 最近剛好看到chisel/FIRRTL專案下有一個子專案叫做diagrammer，可以把FIRRTL進行dependency分析後，產生graphiz的dot檔案，包括其中的submodule都可以一併產生，想說看一下verilog開源的專案有沒有類似的工具。後來找到yosys這個synthesis tool可以達到類似的功能。yosys主要針對verilog-2005，systemverilog之類的沒有支援有點可惜。
用法先去clone該專案，進行安裝。
$ git clone https://github.com/YosysHQ/yosys 安裝相依工具：
$ sudo apt-get install build-essential clang bison flex \  libreadline-dev gawk tcl-dev libffi-dev git \  graphviz xdot pkg-config python3 libboost-system-dev \  libboost-python-dev libboost-filesystem-dev zlib1g-dev 進去yosys資料夾後，選擇compiler:
$ make config-clang $ make config-gcc 然後make &amp;amp;&amp;amp; make install
$ make $ sudo make install 這些步驟都跟readme寫的一樣。
這工具的command和vcs蠻相似的，執行yosys會進到command shell，透過read_verilog載入verilog module，或是read -sv載入verilog module同時elaborate。之後指定top module。她會產生檔案的AST。
yosys&amp;gt; read -sv folder/*.v yosys&amp;gt; hierarchy -top top_module 接下來可以用show指令顯示diagram。</description>
    </item>
    
    <item>
      <title>Linux kernel: Energy Aware scheduling (EAS)</title>
      <link>https://daichou.github.io/posts/energy-aware-scheduling/</link>
      <pubDate>Thu, 04 Jul 2019 00:32:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/energy-aware-scheduling/</guid>
      <description>Energy Aware scheduling 之前寫的作業報告，我覺得可以分享出來
hackmd版：https://hackmd.io/@Daichou/ByzK-S60E
主要文章：https://www.linaro.org/blog/energy-aware-scheduling-eas-progress-update/
背景 本文主要以linaro 於2015年提出之EAS(Energy aware scheduling)框架看當今Linux kernel 5.0以後從EAS與Android端整合回kernel的EAS與EM(energy model)。
自從Arm big.LITTLE 從原本的硬體切換叢集大小核，到後來的HMP(heterogeneous multi-processing)，傳統Linux的SMP排程方式不敷使用，由於傳統Linux kernel的CFS(Completely Fair Scheduler)是以吞吐量(throughput)為主，對於移動平台的功耗掌控不甚理想。因此Arm與Linaro團隊提出了EAS作為對於HMP下Linux CFS,cpuidle,cpufreq子系統的加強。後來導入EM 框架，作為EAS與driver與其他Linux子系統，如：device tree與Thermal(目前仍未連接)的介面。
Energy Model Framework Interface EM(energy model Framework)是Linux kernel特別抽出的介面，用來讓子系統或是driver可以透過em_register_perf_domain()函式註冊一個特別情況下的時脈與功耗的關係(performance domain)。
如上圖可見driver透過em_register_perf_domain註冊效能資料，Kernel透過em_pd_energy()取得功耗估計，而em_cpu_get()用以取得EM中的energy model table的資料。目前僅有Scheduler需要這些資料，不過Linux kernel預期會有更多子系統需要這些資料，因此將特別抽出建立一層抽象化。
OPP(operating performance points) 由於當前SOC盛行，SOC有許多子模塊(例如：CPU cluster)，這些子模塊可以依照使用情境給予不同的頻率與電壓組合，並不一定需要整個SOC依照相同頻率運作，這些子模塊通常被分為domain，各domain可以有多組頻率與電壓組合被稱為operating performance points(OPP)。OPP透過device tree source(dts)由開發者建立，通常於開機時初始化。
(資料來源:https://www.linaro.org/assets/blog/EAS-image-11-f4a331f605b5adbd4d8330917f421070c2b0fc0e7d4fd2e22de1cbe2bf8e83c5.jpg)
以上圖為例由於CPU的算力與功率是曲線而非直線，因此透過OPP可以增加EM推算未來功耗的準確度，這項設計可讓EM預測功耗的線性內插運算更為精準。
Performance domain(perf_domain) 整個performance domain結構如上圖。每個cpu run queue會指向一個root_domain（用以表達一個cpu set），每個root_domain會用linked list儲存多個perf_domain，每個performace domain中的CPU必須是相同的microarchitecture(例如均為Cortex-A53)且當調整一個perf_domain的物理參數(如電壓等)，整個perf_domain中的硬體均會一起被調整，每個perf_domain對應的em_perf_domain會透過em_register_perf_domain()與對應的callback function建立em_cap_state。以從device tree建立的方式為例，em_register_perf_domain()會透過OPP的_get_cpu_power()依照：
 Power = Capacity * Voltage^2 * frequency
 公式將OPP轉成mW、frequency以及cost組合存入em_cap_state，其中cost計算方式為:
 Cost = max_cpu_frequency * em_cap_state.</description>
    </item>
    
    <item>
      <title>AArch64 Linux kernel on Qemu</title>
      <link>https://daichou.github.io/posts/aarch64-linux-kernel-on-qemu/</link>
      <pubDate>Mon, 17 Jun 2019 05:55:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/aarch64-linux-kernel-on-qemu/</guid>
      <description>一、需求  Linux kernel:以5.1.7為例 buildroot qemu toolchain:以linaro為例也可使用Arch linux aarch64-linux-gnu-gcc來編譯(但需要linaro)  二、下載toolchain 在linaro官網的下載區https://www.linaro.org/downloads/，進行下載。以最新第七版為例https://releases.linaro.org/components/toolchain/binaries/latest-7/aarch64-linux-gnu/，下載linux版本即可，然後找個地方解壓縮。
三、下載或編譯Qemu 在arch linux中用pacman安裝qemu。
$sudo pacman -Sy qemu 或是去https://www.qemu.org/下載qemu，或是用git clone。
$ git clone git://git.qemu.org/qemu.git qemu.git $ cd qemu.git $ ./configure --target-list=aarch64-softmmu $ make 之後執行檔會放在qemu.git/aarch64-softmmu/qemu-system-aarch64。
Arch Linux的package預設包含aarch64-softmmu這個target。
四、建立rootfs 其實有很多方法可以建立(busybox)，而這裡用buildroot來做。
首先取得buildroot。
git clone git://git.buildroot.net/buildroot buildroot.git $ cd buildroot.git $ make menuconfig 在target option中選擇架構與CPU。
以下為範例：

在System configuration &amp;mdash;&amp;gt; 點選[*]Run a getty (login prompt) after boot &amp;mdash;&amp;gt;並將TTY port設成ttyAMA0。
在Target Packages &amp;mdash;&amp;gt;選取busybox與[*] Show packages that are also provided by busybox 。</description>
    </item>
    
    <item>
      <title>2018 COSCUP Day2</title>
      <link>https://daichou.github.io/posts/2018-coscup-day2/</link>
      <pubDate>Sun, 19 Aug 2018 02:28:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/2018-coscup-day2/</guid>
      <description>flatpak vs. snap  https://hackmd.io/c/coscup18-gnome/%2Fcoscup18-gnome301-flatpak-snap 按照官網說法，flatpak就是一種container，透過OCI format和cgroups等科技達成sandbox，snap也是類似的東西。https://flatpak.org/faq/ flatpak的app比較多，但是也比較雜，不過其支援ROS打包未來應可以應用。    回望踏入 Linux 内核之旅  https://hackmd.io/c/coscup18-misc/%2Fcoscup18-misc101-linux-kernel https://mp.weixin.qq.com/s/Dgq35AUIBy5nMUKPBwR5ag 中國人很喜歡哲學again XD 我覺得對岸的OS教得比較深入(西安交大)，教授會要求學生進去看sub module。同時也會與學生組織讀書會一起討論。 Understanding the Linux Kernel(ULK)難，深入屬於進階 Linux kernel development(LKD)簡單，適合入門。 Linux device driver屬於實做型    uTensor: AI on Microcontroller   https://hackmd.io/c/coscup18-data/%2Fcoscup18-data-utensor
  https://github.com/uTensor/uTensor
  在MCU上跑Tensor，由於MCU功耗極低，而且超便宜，若能將部份機器學習推論部份搬至MCU上會在應用上更有幫助。然而MCU有其限制，例如code size,ram size小，而且又很慢，因此僅適合做推論。為了克服ram太小問題，可以將資料存於SD卡中(SDTensor)或是ROM（ROMTensor），其中ROM tensor可以不需要SD卡。在編譯期的優化需要判斷哪個Tensor最常被Reference，讓其停留於MCU的data memory中。至於應用，可以用在Sensor Fusion，對資料做前處理，減少傳遞的資料量。也可以做輸入辨識。
  uTensor建立在ARM mbed平台上。即便如此，程式碼須撰寫的數量仍多，因此有了utensor_cgen的專案，將python tensor轉為uTensor。
  uTensor專案下方有對於edge computing做介紹。
  其他：同場加映-山嵐拉麵   
湯濃，但是略油，料豐，但是略貴</description>
    </item>
    
    <item>
      <title>2018 COSCUP day 1</title>
      <link>https://daichou.github.io/posts/2018-coscup-day-1/</link>
      <pubDate>Sun, 19 Aug 2018 02:18:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/2018-coscup-day-1/</guid>
      <description>Introduction to Julia 308  https://hackmd.io/c/coscup18-julia/%2Fcoscup18-julia-introduction-to-julia https://www.slideshare.net/ssuserd6984b/coscup-introduction-to-julia 『Write like Python, run like C.』沒什麼比這句或更有吸引力了，這個語言一本上是語法融合R+Python的動態型別語言，不過她速度實測上接近C和Lua，不過按照講者說法Julia需要在宣告時給定變數型別才可獲得最佳效能。 pass by sharing，function內變數指向原本的參數位置 語法上有趣的部份是他的陣列Index是從1開始的，陣列支援comprehension展開，此外支援複數型別和有理數型別，而且在有UTF-8，可以輕易的打出希臘字母，對於學術界來說時的親切。也因此金融界，和科學運算界用這個語言比較多。我覺得她可以取代Scipy和Numpy在這些領域的地位。 有內建的profile tool，不用像C/C++需要prof或是valgrind。可以用@time產生火焰圖。 有平行語法@parallel修飾字，基本上就是openmp的#pragma parallel for之類的包裝。 @code_native與@code_llvm的修飾字可以方便了解當時程式的組語以及LLVM IR。 Machine Learning,Deep Learning和web full stack均有套件，還也史上最強大微分方程套件。    小鴨城 (Duckietown)，一個基於 Raspberry Pi 和 ROS 的開源無人小車專案介紹  https://hackmd.io/c/coscup18-misc/%2Fcoscup18-misc307-duckietown Ubutu + ROS + OpenCV + Raspberry Pi用來訓練學生對於無人車的設計基本了解。 主要注重車子與雙黃線的距離估計，圖像與真實世界的投影轉換，光影的補完與校正。 交大也有開課歐(軟體創意專題)。 Puyuma    在 RISC-V 上的 ftrace 及 perf 工具移植經驗  https://hackmd.io/c/coscup18-kernel/%2Fcoscup18-kernel-risc-v-ftrace-perf kernel是黑盒子，需要透過ftrace和perf來了解kernel效能。 流程:開發者使用效能監控工具-&amp;gt;改變kernel設定，進入開發模式-&amp;gt;產生監控資料-&amp;gt;離開監控模式-&amp;gt;開發者存取資料 Ftrace:以 function 為等級的監控，進入每個函數，綁架正流執行流程，產生執行與離開的時間戳記，使用者透過透過 tracefs 檔案系統取的 trace 內容。 Perf ： 以 process 為等級的監控，排程器在排入形成時啟動、形成離開時移除 perf 機制，產生包括軟體組態，以及硬體counter，甚至cache miss資料。透過一些gui tool 或是 CLI 獲得perf解碼資料。 均須在compile時加入 -pg flag，插入_mcount _mcount 如何運作，透過更改call stack中當前的return address，讓其進入_mcount產生資料進行計算。https://github.</description>
    </item>
    
    <item>
      <title>Perlman / Film Music - Cinema Serenade (帕爾曼的電影琴聲)</title>
      <link>https://daichou.github.io/posts/perlman-film-music-cinema-serenade/</link>
      <pubDate>Wed, 25 Jul 2018 07:24:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/perlman-film-music-cinema-serenade/</guid>
      <description>Perlman / Film Music - Cinema Serenade (帕爾曼的電影琴聲) 一、資訊 電影：請見曲目
配樂作家： 很多
演奏：Perlman, Itzhak
發行廠商：Sony Music

Perlman / Film Music - Cinema Serenade
 二、心得感想
這張基本上沒什麼好說的，帕爾曼加上John Williams還有其他經典電影等於&amp;quot;買買買&amp;rdquo;。
尤其是辛德勒的名單，還是帕爾曼最對味。
這張的第二首應該算是很常聽到(每次電視跳tango都是拿這首)，不過不知道曲名，而這張剛好有機會讓我重新認識這首。第四首的郵差讓我驚豔，害我特別去spotify找整張來聽，以後有機會應該會入手。
三、曲目  紫色姐妹花(The Color Purple: Main Title) 女人香(Scent of a Woman: Tango (Por Una Cabeza)) 楊朵(Yentl: Papa, Can You Hear Me?) 郵差(Il Postino: Theme) 純真年代(The Age of Innocence: Theme) 遠離家園(Theme from Far and Away) 秋水伊人(The Umbrellas of Cherbourg: I Will Wait for You) 末日四騎士(Four Horsemen of the Apocalypse: Theme) 新龍鳳配(Sabrina: Theme) 遠離非洲(Out of Africa: Main Title) 黑色奧菲歐(Black Orpheus: Manha de Carnaval) 辛德勒的名單(Theme From Schindler&amp;rsquo;s List) 新天堂樂園(Cinema Paradiso: Love Theme)  </description>
    </item>
    
    <item>
      <title>The Legend of The Pianist ( la Leggenda del Pianista sull’Oceano ) - Italy Version (海上鋼琴師)</title>
      <link>https://daichou.github.io/posts/the-legend-of-pianist-la-leggenda-del/</link>
      <pubDate>Sun, 22 Jul 2018 07:29:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/the-legend-of-pianist-la-leggenda-del/</guid>
      <description>The Legend of The Pianist ( la Leggenda del Pianista sull’Oceano ) - Italy Version (海上鋼琴師) 一、資訊 電影：海上鋼琴師
配樂作家： Ennio Morricone
發行廠商：Sony Music

The Legend of The Pianist ( la Leggenda del Pianista sull’Oceano ) - Italy Version (海上鋼琴師)
 二、心得感想
這張基本上有名到我都不想寫什麼介紹了XD，不過秉持著紀錄所有我買過得專輯，所以還是隨手打一篇。這片在買之前裡面的音樂幾乎都已經在各個角落聽過了，即使電影只看過一次，在音樂課，在其他專輯(Yo-Yo Ma Plays Ennio Morricone)或多或少經典曲目包括&amp;lt;Playing Love&amp;gt;、&amp;lt;Magic Waltz&amp;gt;、&amp;lt;A Mozart Reincarnated&amp;gt;還是有名又有梗的鬥琴&amp;lt;Enduring Movement&amp;gt;有在接觸電影配樂的朋友都聽過。其中最喜歡的是&amp;lt;Playing Love&amp;gt;、&amp;lt;Magic Waltz&amp;gt;、&amp;lt;A Mozart Reincarnated&amp;gt;，至於鬥琴那首我到覺得還好。其他也有一些較為不有名曲目如帶有爵士風情的&amp;lt;A Goodbye To Friends&amp;gt;等，還有&amp;lt;Tarantella In 3rd Class&amp;gt;也都十分動聽。我覺得這張真的必收。
三、曲目  Playing Love The Legend Of The Pianist On The Ocean The Crisis Peacherine Rag A Goodbye To Friends Study For Three Hands Tarantella In 3rd Class Enduring Movement Police Trailer Thanks Danny A Mozart Reincarnated Child Magic Waltz The Goodbye Between 1990 And Max Goodbye Duet Nineteen Hundred’s Madness N.</description>
    </item>
    
    <item>
      <title>Arduino: High resolution PWM (more than 8bits),Arduino提高PWM resolution</title>
      <link>https://daichou.github.io/posts/arduino-high-resolution-pwm-more-than/</link>
      <pubDate>Sun, 22 Jul 2018 01:34:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/arduino-high-resolution-pwm-more-than/</guid>
      <description>Arduino PWM(analogWrite) Arduino PWM是使用analogWrite，但是其有一個限制，也就是PWM resolution只有256，PWM duty cycle的值只能介於0~255，對於一般的應用來說，這個值還可以應付，但是對於高精度的Servo或是馬達，這個值實在是太小了。(請參考analogWrite)。雖然在有些板子Arduino提供analogWriteResolution這個函式(Zero, Due &amp;amp; MKR Family、參閱：analogWriteResolution)可以將PWM resolution提高至12，更高的值內部會做mapping到比較低解析度。至於其他板子(例如:Arduino Mega 2560)，則需要第三方library支援(或是自己寫)。
Arduino的硬體PWM極限(Arduino Mega 2560) 以Arduino Mega 2560為例，在其datasheet(link)中提到其&amp;quot;Six/Twelve PWM Channels with Programmable Resolution from 2 to 16 Bits&amp;rdquo;，ATmega2560有12個PWM channel，resolution可為2~16bits。所以其實Arduino Mega 2560硬體可以比Arduino Framework設計的resolution高很多。至於為什麼Arduino官方不用16bits呢，我猜是因為為了保證0~255的限制是可以達成。Arduino Framework的PWM frequency是固定的(16 MHz / 64 / 255 / 2 = 490.196Hz，見Secrets Of Arduino PWM)。
而PWM resolution並不是你想要16bits就可以有16bits的resolution，PWM resolution跟PWM frequency息息相關。在ATmega2560中，Frequecy與系統頻率、timer prescaler(除頻器)，還有最常使用的TOP值(限定Timer counter的最大上限)有關。TOP值的大小即為PWM resolution。依據Atmel PWM resolution公式：
 PWM resolution = log(TOP + 1) / log 2
  通常要把PWM resolution拉到最高，PWM frequency會很小，這主要看設計時的選擇。其他細部詳情請見ATmega640/V-1280/V-1281/V-2560/V-2561/V [DATASHEET]第17章。</description>
    </item>
    
    <item>
      <title>對MPLAB X IDE產生之專案導入git</title>
      <link>https://daichou.github.io/posts/mplab-x-idegit/</link>
      <pubDate>Wed, 18 Jul 2018 07:25:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/mplab-x-idegit/</guid>
      <description>MPLAB X IDE產生之專案架構 MPLAB X IDE產生之專案會XXX.x以.x做結尾。常見的檔案樹如下：
. ├── build │ └── default │ └── production │ ├── main.o │ └── main.o.d ├── debug │ └── default ├── dist │ └── default │ └── production │ ├── 4013_test.X.production.elf │ ├── 4013_test.X.production.hex │ └── 4013_test.X.production.map ├── main.c ├── Makefile └── nbproject ├── configurations.xml ├── Makefile-default.mk ├── Makefile-genesis.properties ├── Makefile-impl.mk ├── Makefile-local-default.mk ├── Makefile-variables.mk ├── Package-default.bash ├── private │ ├── configurations.xml │ └── private.</description>
    </item>
    
    <item>
      <title>CMake: find_package and custom find cmake (findXXX.cmake)</title>
      <link>https://daichou.github.io/posts/cmake-findpackage-and-custom-find-cmake/</link>
      <pubDate>Sat, 14 Jul 2018 02:06:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/cmake-findpackage-and-custom-find-cmake/</guid>
      <description>CMake: find_package and custom find cmake (findXXX.cmake) 我個人覺得這主題寫最好的是這篇，我會建議大家可以看這篇，不要看我寫的XD
https://gitlab.kitware.com/cmake/community/wikis/doc/tutorials/How-To-Find-Libraries
find_package find_package是CMake中用來找第三方package的command。這command功能是去找到所需第三方package的資訊(版本、include path、library path等)，並將資訊存入定好的variable中。find_package會曲找尋CMakeLists.txt所在資料夾下的FindXXX.cmake，或是cmake本身定義好的FindXXX.cmake，通常系統路徑是/usr/share/cmake/Modules下(Arch Linux是放在/usr/share/cmake-版本號/Modules下)。基本上有名的package都已經被定義好了。若是想要知道有哪些可用可以自行去路徑下找，或是用:
cmake --help-module-lists 查詢。
在CMake中使用find_package通常會使用類似下列參數。
find_package(OpenCV 3.4.1 REQUIRED) find_package(package_name version [REQUIRED] [QUIET] )，Version非必要，主要看package敘述。REQUIRED和QUIET主要用於相依性，若package為必要用REQUIRED，若沒找到直接報錯。選擇性用QUIET，通常會用類似下列方式達成選擇性。若沒找到package不會報任何錯誤。
find_package(OpenMP) if (OPENMP_FOUND)  set (CMAKE_C_FLAGS &amp;#34;${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}&amp;#34;)  set (CMAKE_CXX_FLAGS &amp;#34;${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}&amp;#34;) endif()透過find_package 定義的-FOUND判斷是否存在。
find_package通常會定義下列四種變數：
  _FOUND : 是否找到
  _INCLUDE_DIRS or _INCLUDES : include path，類似gcc -I/path
  _LIBRARIES or _LIBRARIES or _LIBS : link library 類似 gcc -L/path -l library</description>
    </item>
    
    <item>
      <title>CMake Tricks: 一些小技巧</title>
      <link>https://daichou.github.io/posts/cmake-tricks/</link>
      <pubDate>Fri, 13 Jul 2018 23:19:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/cmake-tricks/</guid>
      <description>CMake Tricks: 一些小技巧 有常在編一些opensource的專案的應該都對CMake不陌生。這篇文章就整理些我在編使用CMake的專案時遇到的一些問題與解法。
追加Compiler flags CMake裡面有一些變數是用來pass compiler flag給compiler，例如：CMAKE_CXX_FLAGS是用來給g++之類的C++ Compiler。這些變數當然是可以修改的。常見比較好的作法按依照該專案開發者定義的BUILD_TYPE來編，CMake裡面有一些常見的BUILD_TYPE，例如：Debug, Release, RelWithDebInfo &amp;hellip;&amp;hellip;等。可以透過在產生Makefile時下：
$ cmake -DCMAKE_BUILD_TYPE=value 來指定BUILD_TYPE，也可以在CMakeLists.txt中修改或是新增：
SET(CMAKE_CONFIGURATION_TYPES  &amp;#34;Release&amp;#34;)來給定。而BUILD_TYPE會使得該BUILD_TYPE中所定義的CMAKE_&amp;lt;LANG&amp;gt;_FLAGS_&amp;lt;BUILD_TYPE&amp;gt;被加入CMAKE_&amp;lt;LANG&amp;gt;_FLAGS中，例如：把build type設為Debug，會使得CMAKE_C_FLAGS_DEBUG被加入CMAKE_C_FLAGS中。這裡cmake官方文件寫得很清楚reference。
若要自行追加flags也可以透過新增或是修改flags到CMAKE_&amp;lt;LANG&amp;gt;_FLAGS中。例如：
SET(GCC_COVERAGE_COMPILE_FLAGS &amp;#34;-g&amp;#34;) SET( CMAKE_CXX_FLAGS  &amp;#34;${CMAKE_CXX_FLAGS} ${GCC_COVERAGE_COMPILE_FLAGS}&amp;#34; )我這裡的作法是新創一個變數GCC_COVERAGE_COMPILE_FLAGS，將其設為&amp;rdquo;-g&amp;rdquo;，然後把她加入CMAKE_CXX_FLAGS中。
此外還有一個簡單有效的作法。由於CMAKE_C_FLAGS會依照環境變數CFLAGS初始化，所以只要修改CFLAGS這個環境變數就好。其他常見的對應如下：
 CMAKE_C_FLAGS -&amp;gt; CFLAGS CMAKE_CXX_FLAGS -&amp;gt; CXXFLAGS  CMAKE_CUDA_FLAGS -&amp;gt; CUDAFLAGS CMAKE_Fortran_FLAGS -&amp;gt; FFLAGS  而若是使用ccmake來產生Makefile，可以在視窗中輸入t開啟進階選項。直接在選單中修改即可。ex:

Option 下選項分為兩種，一是直接下在command line中，另一種則是用ccmake。
下在command line，只要用-D就好，ex：
$ cmake -DCMAKE_BUILD_TYPE=value 然而用這個很難知道，有什麼選項可以下，而且很麻煩，不過如果你build project是用script只能用這招。至於要知道有哪些選項可以透過：
$ cmake -L 得到所有選項以及當前選擇。
另外一種下option的方式是ccmake， 在Arch中安裝cmake套件，Ubuntu中安裝cmake-curses-gui即可，用法就是把所有cmake的指令改成ccmake。
當更新選項重新build時，會因為路徑下有CMakeCache.txt造成build成上一個版本的設定。可以把CMakeCache.txt刪除，或是透過make rebuild_cache重新建立CMakeCache.txt
CMake debug 如果要撰寫cmake最大問題是不知道cmake variable的值，經過運行後會變什麼。可以透過查看CMakeCache.txt或是下cmake -LAH來查看值。</description>
    </item>
    
    <item>
      <title>Blogger Syntax highlight over https</title>
      <link>https://daichou.github.io/posts/blogger-syntax-highlight-over-https/</link>
      <pubDate>Fri, 13 Jul 2018 20:56:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/blogger-syntax-highlight-over-https/</guid>
      <description>Blogger Syntax highlight over https 由於現在blogger要求https，以往的常用的scripts：
 http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js
 會因為是http而造成瀏覽器報錯，而且載入的code通常會失敗。因此這裡提供一個新的解法。
改用以下cdn由cloudflare提供的。就可以讓你的code在https下漂漂亮亮的。
打開blogger-&amp;gt;theme-&amp;gt;編輯HTML，在&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;中新增以下code。
&amp;lt;link href=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/styles/shCore.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34;&amp;gt; &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shCore.js&amp;#34; type=&amp;#34;text/javascript&amp;#34;&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushAS3.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushBash.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushColdFusion.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushCSharp.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushCpp.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushCss.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushDelphi.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushDiff.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushErlang.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushGroovy.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushJScript.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushJava.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushJavaFX.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushPerl.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushPhp.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushPlain.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushPowerShell.js&amp;#39; type=&amp;#39;text/javascript&amp;#39;/&amp;gt; &amp;lt;script src=&amp;#39;https://cdnjs.</description>
    </item>
    
    <item>
      <title>使用LXC建立USB以及X-forward環境(deprecated)</title>
      <link>https://daichou.github.io/posts/lxcusbx-forward-debiandebianarch/</link>
      <pubDate>Fri, 09 Mar 2018 18:51:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/lxcusbx-forward-debiandebianarch/</guid>
      <description>使用LXC建立USB以及X forward環境(deprecated) 因為修課需要一些debian系的工具，不過我不想讓debian系的和Arch Linux混在一起，所以LXC看起來是一個不錯的解。
環境  OS: Arch Linux (4.15.7-1-ARCH) LXC ubuntu on LXC  步驟 LXC準備 安裝 LXC $ sudo pacman -Sy lxc arch-install-scripts debootstap 建立 Host Network (NAT bridge) (Arch Wiki寫得很好看Arch Wiki) 建立/etc/default/lxc-net(詳情見Arch Wiki)
USE_LXC_BRIDGE=&amp;#34;true&amp;#34; LXC_BRIDGE=&amp;#34;lxcbr0&amp;#34; LXC_ADDR=&amp;#34;10.0.3.1&amp;#34; LXC_NETMASK=&amp;#34;255.255.255.0&amp;#34; LXC_NETWORK=&amp;#34;10.0.3.0/24&amp;#34; LXC_DHCP_RANGE=&amp;#34;10.0.3.2,10.0.3.254&amp;#34; LXC_DHCP_MAX=&amp;#34;253&amp;#34; 修改lxc template conf，在/etc/lxc/default.conf新增
lxc.net.0.type = veth lxc.net.0.link = lxcbr0 lxc.net.0.flags = up lxc.net.0.hwaddr = 00:16:3e:xx:xx:xx 安裝dnsmasq
$ sudo pacman -Sy dnsmasq 開啟以及設定開機啟動：
sudo systemctl start lxc-net sudo systemctl enable lxc-net 建立container (ubuntu) 建previleged的container</description>
    </item>
    
    <item>
      <title>使用SW4STM32建置STM32 HAL專案</title>
      <link>https://daichou.github.io/posts/sw4stm32stm32-hal/</link>
      <pubDate>Sat, 03 Feb 2018 01:13:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/sw4stm32stm32-hal/</guid>
      <description>使用SW4STM32建置STM32 HAL專案 上學期修課時需要的一些小技巧紀錄一下。有人蠻多人問過我，所以打一篇文章。
步驟 其實滿簡單的，只要在建立新專案時多勾選一個選項即可。

當選擇完板子時不要急著案完成，繼續按下一步。

下一步後，勾選Hardware Abstraction Layer(HAL)，即可導入ST官方提供之HAL library。其他還有一些第三方library如FreeRTOS等，也可在這裡新增。
結果 SW4STM32會建立如下專案：

其中HAL會獨立在HAL_Driver下。有幾個檔案要特別注意。
src/stm32l4xx_it.c和inc/stm32l4xx_it.h這兩個檔案為放置Interrupt handler用的檔案，如有新增的Interrupt handler最好是放在這裡。
src/system_stm32l4xx.c：這個檔案放置系統開機時的初始化(clock和RCC)。
src/syscalls.c：這個檔案放置syscall，如果需要將printf的輸出導到UART，就需要在這個檔案動手腳。如下重新定義_io_putchar(int ch)
其他 若要將其他的STM32CubeMX產生出的檔案放入SW4STM32產生之HAL專案，編譯時可能會遇到一些問題。如：void HAL_MspInit(void) redefination。原因是HAL_Driver/Src/stm32l4xx_hal_msp_template.c這個檔案會有衝突，處理方法即是刪除此檔。</description>
    </item>
    
    <item>
      <title>Chasing Pianos: The Piano Music Of Michael Nyman / Valentina Lisitsa Soundtrack Collection</title>
      <link>https://daichou.github.io/posts/chasing-pianos-piano-music-of-michael/</link>
      <pubDate>Sat, 03 Feb 2018 00:30:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/chasing-pianos-piano-music-of-michael/</guid>
      <description>Chasing Pianos: The Piano Music Of Michael Nyman / Valentina Lisitsa 一、資訊  電影：鋼琴與他的情人（The Piano）、《奇異果夢遊仙境》（Wonderland）、《繪圖師的合約》（The Draughtsman’s Contract）、《千鈞一髮》（Gattaca）、《一加二的故事》（A Zed &amp;amp; Two Noughts）、安妮日記(The Diary of Anne Frank) 、Drowning by Numbers 、Carrington、The End of The Affair 、Man With a Movie Camera、The Claim 配樂作家： Michael Nyman
演奏：Valentina Lisitsa
發行：Decca

Chasing Pianos: The Piano Music Of Michael Nyman / Valentina Lisitsa
 二、心得感想
我第一次聽到Michael Nyman這位編曲家是在千鈞一髮(Gattaca)這部我非常喜歡的電影(看看這個部落格的名字就知道了)，當時我不是很懂何謂極簡主義音樂，到了近年聽了許多極簡主義的音樂，例如:Philip Glass、Max Richter(後極簡)。等人的作品才開始了解極簡主意的魅力，透過同樣緩慢推移的模式將情緒注入其中。當然同樣的模式一直出現有時也被其他人批評。不過我覺得這類音樂有打動到我，在電影中讓情緒昇華這樣就夠了。
Michael Nyman最有名的配樂作品當屬&amp;lt;鋼琴師與她的情人&amp;gt;(The piano)這部電影了。而這張CD將這部電影中最精華的幾段配樂提取出來。至於其他電影我到是都沒聽過。
三、曲目  The Heart Asks Pleasure First (Copyright 1993, published in Michael Nyman The Piano Collection) From The Piano 04:21 Big My Secret (Copyright 1993, published in Michael Nyman The Piano Collection)From The Piano 02:58 Candlefire From The Diary of Anne Frank 02:29 If (Published 2005 in Michael Nyman The Piano Collection) From The Diary of Anne Frank 03:34 Sheep ‘n’ Tides From Drowning by Numbers 02:32 Goodbye Moortie From The Diary of Anne Frank 01:53 ly Drive From Carrington 00:51 Diary of Love From The End of The Affair 02:44 Time Lapse From A Zed &amp;amp; Two Noughts 04:54 Odessa Beach From Man With a Movie Camera 03:32 The School Room From The Diary of Anne Frank 02:12 Why?</description>
    </item>
    
    <item>
      <title>Cloud Atlas Original Soundtrack</title>
      <link>https://daichou.github.io/posts/cloud-atlas-original-soundtrack/</link>
      <pubDate>Fri, 06 Oct 2017 09:37:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/cloud-atlas-original-soundtrack/</guid>
      <description>Cloud Atlas Original Soundtrack 一、資訊 電影：雲圖(Cloud Atlas)
配樂作家： Tom Tykwer、Johnny Klimek、Reinhold Heil
發行：Sony Music

CLOUD ATLAS ORIGINAL MOTION SOUNDTRACK
二、心得感想 這部電影其實我沒看過，我當初是因為偶然聽到了這部電影的配樂&amp;lt;Cloud Atlas Sextet&amp;gt;和&amp;lt;Prelude: The Atlas March&amp;gt;後跑去找了這部電影的原著小說來看。這部電影小說的敘事手法十分有趣。她其實六段故事以A-B-C-D-E-F-F-E-D-C-B-A的方式敘述的，而且每段故事時間相差很久，但是前段的故事會有部份連結到下一段，表現出&amp;quot;輪迴&amp;quot;的感覺。當然這種敘事方式拍成電影爆炸機率相當高的，而電影得票房也真的炸了。
如同敘事手法，配樂本身也是有A-B-C-D-E-F-F-E-D-C-B-A的曲目編排。有多首配樂的風格式成對的。不過其中最引人注目的仍是書中提到的&amp;lt;雲圖六重奏&amp;gt;，這首貫串整個故事的曲子。也就是&amp;lt;Prelude: The Atlas March&amp;gt;，之後包括&amp;lt;Cloud Atlas Opening Title&amp;gt;、&amp;lt;Cloud Atlas Finale&amp;gt;、&amp;lt;The Cloud Atlas Sextet for Orchestra&amp;gt;和&amp;lt;Cloud Atlas End Title&amp;gt;，我覺得光片尾幾首曲子的編排與交響編曲，這張專輯就很有收藏的價值了。當然片中的&amp;lt;Templa of Sacrifice&amp;gt;和&amp;lt;All Boundaries Are Conventions&amp;gt;也是我喜歡的曲子。不過剩下幾段的風格我不是很喜歡。
不過這張專輯聽的時候有發現一個問題，最後幾首有時會有不名聲響，我不確定是不是錄音失誤，還是刻意的。
三、曲目  Prelude: The Atlas March Cloud Atlas Opening Title Travel to Edinburgh Luisa’s Birthmark Cavendish In Distress Papa Song Sloosha’s Hollow Sonmi-451 Meets Chang Won’t Let Go Kesselring The Escape Temple Of Sacrifice Catacombs Adieu New Direction All Boundaries Are Conventions The Message Chasing Luisa Rey Sonmi’s Discovery Death Is Only A Door Cloud Atlas Finale The Cloud Atlas Sextet for Orchestra Cloud Atlas End Title  </description>
    </item>
    
    <item>
      <title>The Imitation Game Original Soundtrack </title>
      <link>https://daichou.github.io/posts/the-imitation-game-original-soundtrack/</link>
      <pubDate>Wed, 04 Oct 2017 10:38:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/the-imitation-game-original-soundtrack/</guid>
      <description>The Imitation Game Original Soundtrack  一、資訊 電影：模仿遊戲(The Imitation Game)
配樂作家：Alexandre Desplat
發行：Sony Music

THE IMITATION GAME
二、心得感想 這部電影我本身蠻喜歡的，因為我是資訊背景，這故事本身就有親切感(讀過資工系的或多或少聽過圖零機吧)，雖然劇情魔改了Alan Turing的故事，但是改的還算流暢。唯一需要吐嘈的應該就是把發現德軍密碼會有固定內容，而這些內容可以用來剪枝(替除不可能發生的組合)部份改的太戲劇化了。
音樂部份為了呈現Alan Turing數學家的特質，讓音符很離散，很像一群數字在舞動。尤其在、、會有一種問題被拆解被處理的感覺。當然主題旋律&amp;lt;The Imitation Game&amp;gt;和&amp;lt;Alan Turing&#39;s Legacy&amp;gt;寫的很有味道。我當初在戲院看到這部電影時有被這兩首曲子觸動。&amp;lt;The Apple&amp;gt;、&amp;lt;Farewell To Christopher&amp;gt;是片中圖靈生命最悲情的時刻，這些悲傷讓我們對圖靈，還有對同性戀的迫害起了反思。
由於我仍是學生，財力不是十分充足，當初看完這部電影後一直去spotify反覆聽這片原聲帶，最後才決定買實體的，以更好的音質品味這張專輯。
三、曲目  The Imitation Game Enigma Alan U-Boats Carrots And Peas Mission Crosswords Night Research Joan Alone With Numbers The Machine Christopher Running Christopher Is Dead Decrypting A Different Equation Becoming A Spy The Apple Farewell To Christopher End Of War Because Of You Alan Turing’s Legacy  </description>
    </item>
    
    <item>
      <title>Arduino TLC5940與伺服馬達</title>
      <link>https://daichou.github.io/posts/arduino-tlc5940/</link>
      <pubDate>Fri, 08 Sep 2017 22:39:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/arduino-tlc5940/</guid>
      <description>Arduino TLC5940與伺服馬達 TLC5940介紹 TLC5940是TI的16 channel LED驅動晶片。可以支援同時16通道的PWM灰階輸出，解析度為4096階。同時有兩種模式 12 bit (4096 Steps) Grayscale PWM Control 和 Dot Correction。
重要參數：
供應電壓：Vcc =&amp;gt; 3V ~ 5.5V
操作界面：Serial Data
資料傳輸速率：~30MHz
LED可驅動最大電壓：~17V
LED可驅動電流：0~60mA(Vcc &amp;lt; 3.6V ) 0~120mA(Vcc &amp;gt; 3.6V)
由於是輸出PWM，也可以拿來做PWM擴充。所以也可以拿來推Servo摟。
TLC5940 Ardunio library 在Ardunio IDE中可以透過library manager找到。而github上也有連結：
https://github.com/PaulStoffregen/Tlc5940
TLC5940電路接法 以下以PDIP封裝的TLC5940為例還有使用Arduino Mega2560。

   TLC5940 Arduino Mega2560     SIN(pin 26) MOSI(pin 51)   SCK(pin 25) SCLK(pin 52)   XLAT(pin 24) OC1A(pin 11)   BLANK(pin 23) OC1B(pin 12) + 1K ohm上拉電阻   GSCLK(pin 18) OC2B(pin 9)   VPRG(pin 27) VPRG(pin 50) or GND   XERR(pin 16) XERR(pin 10) or GND   SIN(pin 26) SIN(pin 51)   IREF(pin 20) 1K ohm下拉電阻   VCC(pin 21) 5V   GND(pin 22) GND    至於out0到out15的接法比較特別。</description>
    </item>
    
    <item>
      <title>STM32 LCD 使用 BSP 與STM32CubeMX</title>
      <link>https://daichou.github.io/posts/stm32-lcd-bsp-stm32cubemx/</link>
      <pubDate>Thu, 07 Sep 2017 08:03:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/stm32-lcd-bsp-stm32cubemx/</guid>
      <description>STM32 LCD 使用 BSP 與STM32CubeMX 本文以STM32F469NI Discovery為範例。目標是以STM32F469的BSP lib操作STM32F469 Discovery的TFT-LCD。
STM32CubeMX configuration 先將周邊開啟如以下設定。

LTDC : LCD-TFT Display Controller，硬體優化的LCD控制介面。
DSIHOST: Display Serial Interface Host，由MIPI alliance建立的行動顯示protocol。提供高速的LCD framrate。
DMA2D : Chrom-Art Accelerator™ 用來做圖像操作的DMA，可以做出限定範圍的填滿等記憶體操作。適用AHB bus，可以將結果導入AHB slave端(DSI HOST)。
RCC : LTDC , DSI HOST需要時序。
I2C : 觸控需要。(stm32f469_discovery.c需要I2C)。
FMC : 用BSP時可以選擇使用SDRAM存儲資料。

時脈控制，由於開啟HSE，所以DSI有了clock source。(這部分要注意STM32CubeMX產生出來的程式碼是否會讓clock超過硬體限制)。

選擇RGB565為color mode。

Pixel format選用ARGB8888。
 引入Driver
在專案資料夾下的Drivers/BSP/Components/otm8009a 中，將該路徑下的otm8009a.c 加入keil專案。otm8009a為STM32F469_Discovery上的觸控顯示螢幕。
在專案資料夾下的Drivers/BSP/STM32469I_Discovey中，將該路徑下的stm32469i_discovery.c、stm32469i_discovery_lcd.c、stm32469i_sdram.c加入keil專案中。
去下載STM32CubeMX STM32F4 firmware link: http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32cube-embedded-software/stm32cubef4.html
解開來，將Utilities資料夾放入project根目錄。
新增好的檔案架構如下。

在options for target -&amp;gt; C/C++ -&amp;gt; include path中加入那兩個資料夾。如下:</description>
    </item>
    
    <item>
      <title>STM32CubeMX初探</title>
      <link>https://daichou.github.io/posts/stm32cubemx/</link>
      <pubDate>Mon, 04 Sep 2017 07:31:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/stm32cubemx/</guid>
      <description>STM32CubeMX初探 STM32CubeMX是code generator(程式碼產生器)，與Microchip code configurator一樣。目標是用圖形化方式規劃MCU的外部模組與內部Middlewares設定。我個人覺得使用STM32cubeMX可以讓整個開發更加&amp;quot;工程化&amp;rdquo;，產生的專案會更有組織。
一、安裝與更新 安裝網址如下:http://www.st.com/en/development-tools/stm32cubemx.html
下載完成後，桌面會產生兩個icon，一個是STM32CubeMX，一個是STM32CubeUpdater。
開啟STM32CubeUpdater，選擇所需的STM32系列library，即可完成相依library建設。更新也是透過此工具。
二、基本使用(以STM32F469NI_Discovery為範例) 開啟STM32CubeMX，選擇New Project-&amp;gt;選擇晶片或是開發版即可進入。如下圖畫面。

# pinout 左邊為周邊模組(peripheral)綠色為已經啟用。左邊為腳位設定(綠色為已規劃，橘色為開發版已經硬體連接的腳位但未啟用)。左鍵點選腳位可以開啟小選單選擇所需腳位定義。
透過上方tab進入進階規劃。

#Clock Configuration 
這個tab將STM32的所有時序和PLL、prescaler列出整理成流。
幾乎所有設定都可以修改。後方藍色框框中可以直接鍵入所需Clock值，系統會幫你調整整個流。當然有硬體限制，STM32cubeMX會提醒你，當你出現錯誤設定會有警示。
 #Configuration

這個tab將前面所開啟的周邊模組列出，每個都可點選以進階設定。更詳細的設定之後文章會介紹。 #power consumption calculator 
這個tab可以幫助計算能源消耗，還可以計算各個環境下的情況(就是把datasheet後面的數據列出)，不過無法計算開發版的能源消耗，僅限晶片本身。
# project Settings 點選上方menu-&amp;gt;Project-&amp;gt;Project Settings，開啟以下專案設定。

基本上就按照環境選了。不過這裏特別提一個選項，我覺得對後續開發很以幫助。

紅框中選項可以將周邊裝置的初始化函式(以MX_為前綴的函式)產生成獨立的.c/.h配對，避免全部Init函式都在main中，造成main function很肥大，而且當你有多個source檔(並非主要程序都集中在main.c)時，可以讓其他函式更方便引用這些初始程序。
 #產生Project與報告

紅框中這兩個東西可以產生Project 與報告。
#結果與檔案樹(以ARM MDK keil為例) 
User裡面是初始化函式和main.c。可以發現main.c中有一堆USER code begin和USER code end的註解，這些註解是希望user將自己的code加入其中，因為如果要重新使用STM32CubeMX產生code到同一專案時，可以確保user code不會被覆蓋。
Drivers/STM32F_4xx_HAL_Driver是STM官方在推的HAL函式庫，現在的主流，這部分引用都是由STM32CubeMX完成，其中若是想要自行開啟周邊模組，可以在這個資料夾中的stm32f4xx_hal_conf.h中解除註解或新增註解(外面檔案樹的Inc中)。若有新增模組需要手動將該周邊的HAL的.c新增進專案中。
# 小結 STM32CubeMX的有點是可以讓開發工程化，開發速度加快，可以用高層級的方式思考整個系統架構，而且不用去一直翻閱datasheet(最好還是要了解整個周邊的架構與使用)。
缺點是一些官方套件，例如:STemWin和BSP要自行新增進入專案中，有點可惜。</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43;中避免unused variable造成報錯的方法(void cast of argc/argv)</title>
      <link>https://daichou.github.io/posts/ccunused-variablevoid-cast-of-argcargv/</link>
      <pubDate>Thu, 13 Jul 2017 01:21:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/ccunused-variablevoid-cast-of-argcargv/</guid>
      <description>一些Signal handler或是Thread(CMSIS-RTOS)的建立會要求你的的函數強制吃一些argument。
當你的compiler開 -Werror -Wall -Wunused-variable選項時,這些未被使用的變數會報錯。
這時有兩個解法。
 void cast  例如:
void f(void * argc) { (void) argc; } 這會無害的去用到這個變數。
2.自己等於自己
例如:
void f(void * argc) { argc = argc; } 這兩招就是欺騙compiler這些變數已經被使用。
我第一次看到這寫法真的嚇到了。
以下是stackoverflow的討論。
https://stackoverflow.com/questions/21045615/what-does-voidvar-actually-do
https://stackoverflow.com/questions/8052091/void-cast-of-argc-and-argv?rq=1</description>
    </item>
    
    <item>
      <title>A Narrative History of BSD 心得</title>
      <link>https://daichou.github.io/posts/a-narrative-history-of-bsd/</link>
      <pubDate>Sun, 09 Jul 2017 01:36:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/a-narrative-history-of-bsd/</guid>
      <description>A Narrative History of BSD 這篇文為我修課時做的心得,由於原文是用hackmd寫的,在這裡版型會有差異(原文)
  什麼是BSD
 全名：Berkeley Software Distribution(柏克萊軟體套件) 類型：作業系統(UNIX-like) 創立者；Bill Joy 程式語言：C license：BSD license 描述：常用於工作站與伺服器 下圖為UNIX譜系
    全片大綱
以下是以影片中Dr. Kirk McKusick的解說分段。
 Bill Joy Era  在柏克萊大學建立 Bill Joy時期(1BSD,2BSD)納入的軟體套件：EX(vi),pascal interpreter,C Shell   TCP create  BSD 4以後的TCP/IP建立 BNN與柏克萊團隊的衝突   lawsuit of license  與AT&amp;amp;T的著作權問題      BSD歷史與提及的對照
以下是BSD的歷史與影片中的內容相互參照。
  1BSD
  釋出：1978年
  由Bill Joy創立，從早期貝爾實驗室的UNIX改寫而來</description>
    </item>
    
    <item>
      <title>The Unix System: Making Computers Easier to Use 心得</title>
      <link>https://daichou.github.io/posts/the-unix-system-making-computers-easier/</link>
      <pubDate>Sun, 09 Jul 2017 01:35:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/the-unix-system-making-computers-easier/</guid>
      <description>The Unix System: Making Computers Easier to Use 這篇文為我修課時作的心得
 摘要
這部影片主要在介紹UNIX的功能與UNIX的好   創造緣由:為了處理電話轉接工作還有解決問題
  UNIX作業系統系統特色
 time-sharing portable multi-tasking hierachical file system IPC pipes    UNIX作業系統架構
分層
描述
kernel
｜底層與硬體溝通 、管理資源
shell
｜與kernel溝通的界面
utility program ｜上層的應用程式
  utility program範例
 sort 拼字檢查(超炫的) 編輯器…等     考古
我有點好奇當時的電腦等級是如何，所以稍微找了一下youtube底下所說的DEC PDP-7規格。   圖片來源:wikipedia PDP-7
 規格：
參數
數值
記憶體
4K words 可加到 64K words</description>
    </item>
    
    <item>
      <title>Revolution OS 心得</title>
      <link>https://daichou.github.io/posts/revolution-os/</link>
      <pubDate>Sun, 09 Jul 2017 01:32:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/revolution-os/</guid>
      <description>Revolution OS 這篇文為我修課時做的心得
  摘要
內容與The Code有所重疊，但對於Linux,GNU,Free software,Open Source的成長其著墨較深，還有各期開發者與使用者加入Linux的情況有所描述。還有開源陣營與Microsft閉源陣營的對抗。主要內容涵蓋：
 GNU、BSD、Linux等社群體系的建立 Linux成長與網路的關聯(apache project) 開源社群的成長與所被業界接受(cisco採用,Oracle,Sybase等企業的貢獻) 運用開源的商業模式(服務:Redhat、VALinux、Cygnus) Linux Torvalds對於用Linux賺錢的看法 Netscape開源與Mozilla Richard Stallman對於Copyleft與自由軟體理念 開源與自由軟體運動的影響  ex:消費者可以購買不含Windows的電腦,Microsoft對於開源態度的改觀(這部影片當時Microsoft仍有點抗拒，到了Satya Nadella當任CEO時期才正式投入)      Note
片中Debian社群提到的Open Source定義原文link
 Free Redistribution Source Code Derived Works Integrity of The Author’s Source Code No Discrimination Against Persons or Groups No Discrimination Against Fields of Endeavor Distribution of License License Must Not Be Specific to a Product License Must Not Restrict Other Software License Must Be Technology-Neutral    心得</description>
    </item>
    
    <item>
      <title>The Code心得</title>
      <link>https://daichou.github.io/posts/the-code/</link>
      <pubDate>Sun, 09 Jul 2017 01:29:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/the-code/</guid>
      <description>The Code * 系列為我修課時留下的心得
* 摘要   Linus Torvarlds 的生平與Linux創作背景
包括家庭背景與當時的社經環境(ex:蘇聯解體)。
因為Minix僅限教育用途，加上當時其他的作業系統過於昂貴(SCO Unix要20000馬克)，還有just hobby等因素，開始著手開發Linux。
  open source精神
這裡直接節錄 Richard Mathhew Stallman 於片頭所說的話『開放原始碼就像是食譜，當有好的食譜，我們可以與他人分享，其他人可以對食譜加入自己的元素與口味，並將食譜回饋給原本的人或是繼續開放食譜下去。』，除此之外，open source不只是將程式原始碼開放下去這個動作，其背後可能同時創造了一個社群。
  Free Software VS Open Source
由 Richard Mathhew Stallman 提出的Free Software觀念與Free Software運動，還有Free Software Foundation對於自由軟體的推廣，讓人們認識到Free Software的意含，但是由於 Richard Mathhew Stallman 與 Free Software Foundation的言論通常較激進，導致齊備一些商人貶低，但是那群人們卻擁抱Open Source觀念(其實包括的軟體多有重疊)，所以Eric S.Raymond認為應該倡導Open Source讓人們接受。
  GNU/Linux對世界的影響
GNU/Linux影響著許多開發者，還有業界一些公司，同時開發中國家的中國與印度的開發人員也對Linux有許多貢獻。Dot com風暴後影響開源軟體的發展與關注度，但是Linux作業系統卻開始進入小型裝置，如：電子鐘、手機等裝置，使一般使用者開始接觸到Linux。
  * 心得 由於在高中時有在接觸Linux作業系統加上現在主要都以Linux作為我的筆電預設作業系統，對對於Linux的歷史本身就有一些了解，不過對於Linux創立前的歷史不甚熟悉，不知道有Richard Mathhew Stallman這位在Linux開發出來前就已經開始宣揚自由軟體理念的靈魂人物，還有BSD本身對於開源觀念的殿基，讓我們可以在現今不受拘束的宣揚Open Source與使用Open Source的軟體，而且由於這些Open Source軟體的出現，讓我們這些後人可以研究這些軟體的技術，還可以貢獻所學於這些軟體中，並讓世界更美好。
* Qustion  Linus常說Linux kernel的開發人員的組織架構是十分扁平的，大家可以自由的提出意見，但是如果開發出Code，想要commit到Linux kernel中，到底是誰負責審理的？ 為什麼Linux社群最蓬勃發展？同樣是開源的BSD系統還有Minix等專案的能見度卻沒這麼高？ Linus說印度的基礎溝通較不好，所以可能會衍生出在地版的Linux，不知有沒有出現?</description>
    </item>
    
    <item>
      <title>I2C 使用Microchip plib</title>
      <link>https://daichou.github.io/posts/i2c-microchip-plib/</link>
      <pubDate>Sat, 29 Apr 2017 21:13:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/i2c-microchip-plib/</guid>
      <description>I2C 使用Microchip plib 本篇以dsPIC30F為主。
plib 安裝 到Legacy PIC24 MCU &amp;amp; dsPIC DSC Peripheral Library下載最新的plib，然後她會要求將plib安裝到你電腦中xc16 complier的資料夾下(linux在”/opt/microchip/xc16”下)。
函式概覽 安裝後文件會在xc16 complier的docs/periph_libs下。
其中plib提供以下函式。
 AckI2C
CloseI2C
ConfigIntI2C
DataRdyI2C
IdleI2C
MastergetsI2C
MasterputsI2C
MasterReadI2C
MasterWriteI2C
NotAckI2C
OpenI2C
RestartI2C
SlavegetsI2C
SlaveputsI2C
SlaveReadI2C
SlaveWriteI2C
StartI2C
StopI2C
 還有一些MARCO
 EnableIntMI2C
DiableIntMI2C
SetPriorityIntMI2C
EnableIntSI2C
DisableIntSI2C
SetPriorityIntSI2C
 這份文件16 bit language tools第191頁開始有詳述這些函式的介面。所以本文主要會面向如何運用這些函式達成master與slave溝通。
I2C (dsPIC30F as Master with 7bit address) reception 以下圖片來自於http://ww1.microchip.com/downloads/en/DeviceDoc/70046E.pdf

對應到plib的流程為。(以下為我在i2cdevlib中所新增的片段，為一次讀多個bytes)。
請先透過ConfigIntI2C和OpenI2C設定好硬體參數。
值得注意的是在dsPIC30F manual中第5步驟。要透過StartI2C再次產生start condition。而讀入多個data bytes可用MastergetsI2C函式。
transmission transmission只要全部都由Master端給資料即可。</description>
    </item>
    
    <item>
      <title>MPU6050 Gyroscope/Accelerometer 使用筆記</title>
      <link>https://daichou.github.io/posts/mpu6050-gyroscopeaccelerometer/</link>
      <pubDate>Thu, 27 Apr 2017 04:38:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/mpu6050-gyroscopeaccelerometer/</guid>
      <description>MPU6050 Gyroscope/Accelerometer 使用筆記 特性與參數  用途：量測姿態 精度：  Gyro : 250/500/1000/2000 dps (degree per second) Accel : +-2/4/6/16 g   輸出資料：為angular rate(角速度) ，16bit , LSB/g 原始感應器電壓VDD(僅有晶片)：2.375V-3.46V 原始晶片通訊電氣參數：  Vlogic = 1.8V (+-5%) OR VDD VIH(Voltage high level) : 必須超過0.7*Vlogic(MPU6050) VIL(Voltage low level):必須低於0.3*Vlogic(MPU6050) Ci(Input Capacitance): &amp;lt;5pF I2C address: 1101000(when AD0 = 0),1101001(when AD0 = 1) I2C最快頻率：400KHZ   模組(GY521)電壓：3~5V 其他特色：  有內建low pass filter可供程式選擇 中斷信號選擇 Auxiliary I2C port可與其他模組串接 可作自我校正 可透過FSYNC pin與外部模組做synchronization (Gyro) On-chip DIgital motion processor 有內建FIFO   通信方式：I2C(MPU6050,MPU6000)/SPI(MPU6000) 晶片datasheet:連結在此  資料單位換算 Gyroscope 首先先看下表為MPU6050 datasheet。</description>
    </item>
    
    <item>
      <title>[Note] GDB 一些指令功能速查</title>
      <link>https://daichou.github.io/posts/note-gdb/</link>
      <pubDate>Fri, 03 Mar 2017 21:09:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/note-gdb/</guid>
      <description>[Note] GDB 一些指令功能速查 前情提要 這篇主要是介紹gdb的一些常用功能，遇到的時候方便google。
常用功能  backtrace breakpoint watchpoint stopwatch dump register dump variable continue and stop disasmmebly return  指令速查  backtrace  bt   breakpoint  b br   watchpoint  watch variable_name or watch variable_address   stopwatch  maint link   dump register  info r   dump variable  print variable_name print &amp;amp;variable_name =&amp;gt; get address print *variable_address =&amp;gt; get address contents info display   continue and stop  c =&amp;gt; continue r= &amp;gt; run stop =&amp;gt; Ctrl+c   disasmmebly  disassemble (func…) link layout asm layout src   return  return (return this stack)     Written with StackEdit.</description>
    </item>
    
    <item>
      <title>L3G4200 gyroscope使用筆記</title>
      <link>https://daichou.github.io/posts/l3g4200-gyroscope/</link>
      <pubDate>Sat, 18 Feb 2017 17:50:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/l3g4200-gyroscope/</guid>
      <description>L3G4200 gyroscope使用筆記 特性與參數  用途：量測姿態 精度：250/500/2000 dps (degree per second) 輸出資料：為angular rate(角速度) ，16bit 原始感應器電壓(僅有晶片)：2.4V ~3.6V 模組(GY50)電壓：3~5V 其他特色：有內建high pass filter和low pass filter可供程式選擇，還有中斷信號選擇 通信方式：I2C/SPIs 晶片datasheet:連結在此 模組(GY50)購買網頁：連結在此  用此模組量測當前姿態方式 軟體部份 Ardunio先安裝wire library和L3G4200D
用這個網站上的code和library即可。
角速度轉成角度 由於該感測器輸出為角速度(離散資料)，所以我們須將角速度做離散積分得到角度。
 角度 ＝ 初始角度 + (角速度*取樣時間的總和)
 下圖為利用QT自製的視覺化工具。其中若要得到角度責須得到線與0軸的面積。

下圖為L3G4200 datasheet p.10 一小部份，其中Sensitivity代表精度，以FS=200dps為例，代表從感測器輸出的數字1代表8.75mdps，如果輸出為兩千時，當前角速度為2000*8.75/1000000dps = 0.0175 dps。

應用限制與誤差處理 由於是作離散積分所以會有誤差，最好使用濾波器(有內建)。
另外由於它需要一直取樣，對Master CPU來說是很大的負擔。
 Written with StackEdit.
 </description>
    </item>
    
    <item>
      <title>Valgrind:C/C&#43;&#43;分析工具</title>
      <link>https://daichou.github.io/posts/valgrindcc/</link>
      <pubDate>Fri, 13 Jan 2017 22:05:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/valgrindcc/</guid>
      <description>Valgrind:C/C++分析工具 Valgrind是開源的測試框架，可以用來動態分析記憶體配置、快取使用、多執行序bug。
安裝 $ sudo pacman -Sy valgrind 基本用法 $ valgrind 程式名稱 args 預設會是用memcheck工具分析，在這個工具下她會匯出heap使用、memory leak、還有記憶體使用錯誤的部份backtrace。 進階用法 $ valgrind --tool=toolname 程式名稱 args 這是valgrind最有方便的地方，valgrind旗下有九個使用者端的工具，和幾個開發者工具。 1. Memcheck:記憶體錯誤分析工具。 2.Cachegrind:預測你的cache使用。 3.Callgrind:分析程式的function call次數，還有call graph，可以幫助快取分析。 4.Helgrind:多執行序錯誤分析工具，有race condition檢測功能。 5.DRD:另一個多執行序分析工具。 6.Massif:分析heap的使用，在一個程式執行中她會測量多次。 7.DHAT:另一種heap分析工具。 8.SGcheck:實驗性的全域變數與stack分析工具。 9.BBV:實驗性SimPoint相關工具。 這些工具比較常用的是前七個。接下來看一下個別的使用。 memcheck $ valgrind --tool=memcheck 程式名稱 args 首先我先寫一個廢物code來做實驗。以下code new完之後沒有delete。
#include&amp;lt;iostream&amp;gt; using namespace std; int main() { int *ptr; ptr = new int; *ptr = 2; cout &amp;lt;&amp;lt; *ptr &amp;lt;&amp;lt; endl; } 然後我們來看一下分析結果。
==12313== Memcheck, a memory error detector ==12313== Copyright (C) 2002-2015, and GNU GPL&amp;#39;d, by Julian Seward et al.</description>
    </item>
    
    <item>
      <title>方便的網站：stackedit</title>
      <link>https://daichou.github.io/posts/stackedit/</link>
      <pubDate>Wed, 14 Dec 2016 00:49:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/stackedit/</guid>
      <description>**
方便的網站：stackedit *在CMS風行一段時間之際，傳統的部落格文書編輯器已經顯得過時無用，調字體大小等這些基本功能用傳統文書編輯器還可以接受，但表格等則還需要動用html，這顯得十分麻煩，這時運用markdown方式撰寫文件的功能的網站如與後出筍般出現，包括hackmd:https://hackmd.io/專案的成功。而部落格方面，除了wordpress的markdown插件，logdown以markdown為訴求的網站平台外，如果使用傳統google所提供的blogger功能的話，首推stackedit:https://stackedit.io，他的功能十分強大，可以幫你管理你的文章還可以串連多個blog平台，包括blogger,wordpress,github,gist,tumblr等，而且畫面簡潔明亮，害我都跳槽了哈哈。
 Written with StackEdit.
 </description>
    </item>
    
    <item>
      <title>[Note]Microcontroller的排程方式</title>
      <link>https://daichou.github.io/posts/notemicrocontroller/</link>
      <pubDate>Wed, 07 Dec 2016 03:06:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/notemicrocontroller/</guid>
      <description>[Note]Microcontroller的排程方式 這篇為我看完Microchip Technology 20024 FRM4 - Interrupt and Task Scheduling - No RTOS Required後所作的筆記。
Race condition與Synchronization Race condition的觀念在恐龍書已經說很多了，所以就不提了。而Synchronization部份，Microcontroller常用interupt disabling和spin lock來做處理，而用到sempahore的部份也是有。另外值得注意的一點是，由於MCU同時有許多peripheral component(Timer,ADC,SPI,UART&amp;hellip;)再運作，這些元件也會改變SFR(special function register)的值，所以建算你的程式是但執行序，仍可能會有race consition發生，例如：在PIC的 16 bit timer中，他是分成兩個register控制timer的值(TMR1L,TMR1H)，也就是說你要更動timer的值時，需要大於兩個cycle，才可辦到，但是如果在存取值的時候你的timer仍在運作，則可能發生，不合理的狀況。比方說你想要讀取TMR1的值(TMR1H + TMR1L)，原本TMR1H = 0x00,TMR1L = 0xFF，第一部份，你讀到了TMR1H的值為0x00，但在第二部份時你要讀TMR1L的時候，因為timer仍在計時，經過一個cycle，TMR1L的值已經加1並進位到TMR1H，所以TMR1L的值現在為0x00，你讀到的值就是0x00，在這個case中，你預期你會得到(0x00,0xFF)，但你實際上拿到(0x00,0x00)，這是在MCU常有的情況。避免的方法為暫停timer然後再去取值。
 Review interrupt
在MCU中硬體發生的中斷會已硬體的context switch實做，也就是她會將當前的core register複製一份到shadow register儲存，保留狀態，當離開ISR後，CPU會將shadow register載回core register中。
在interupt中，對於跨ISR與main line的變數，可以考慮使用Volatile修飾字(一個資源有多個process使用時，透過這個修飾字可以告訴編譯器，不要對這個值做值域判斷優化)，以免編譯器編出你無法預期的行為。
interrupt在context switch時會有所謂的interrupt latency(在IVT中尋找對應的interrupt vector+context switch+當前指令的完成(例如說MUL))，這是MCU的效能指標之一，不過對於多層的interrupt，在第二層以後失去了硬體context swtich的優化，所以速度會慢很多。
Jitter injection為main line在被中斷後所暫停執行的時間，通常要盡量讓Jitter 愈小愈好。
interupt priority:MCU中的interrupt有priority，規範誰可以中斷誰，例如說PIC18F系列有兩個level，dsPIC30F系列有八個level，此外MCU中透過interrupt 在IVT的順序，有所謂的natural order priority，來處理相同level intertupt同時發生的問題。另外，ISR裡可以包裹多個interrupt handler，這部份一樣是透過IVT先後和priority還有發生時間決定進入點。(其他:可重入程序)。
一些ISR設計的注意細節:
1.盡量ISR短，減少jitter
2.避免無限的等待
3.盡量避免ISR與mainline使用相同的全域變數(有的話記的要加volatile)
Review scheduler(非Real time)與相關技術 有cooperative與preemptive兩大類，恐龍書有詳盡描述。此外還有兼容兩種特性的(hybird)。
常見排程方式與技術有：</description>
    </item>
    
    <item>
      <title>C99 fast data type</title>
      <link>https://daichou.github.io/posts/c99-fast-data-type/</link>
      <pubDate>Tue, 06 Dec 2016 20:05:00 -0800</pubDate>
      
      <guid>https://daichou.github.io/posts/c99-fast-data-type/</guid>
      <description>C99 fast data type 這個主題是我在看完Efficient C Tip #13 – use the modulus (%) operator with caution這篇文章發現的C99在stdint.h新規範的一些資料型態，所作的小小理解。
C99 fast data type，為一種針對硬體CPU架構所提出的資料型態。主要有這下列八種型態：
uint_fast8_t 
uint_fast16_t
uint_fast32_t
uint_fast64_t
int_fast8_t 
int_fast16_t
int_fast32_t
int_fast64_t
在C99 7.18.1.3是這樣做定義的：
1 Each of the following types designates an integer type that is usually fastest 219) to operate
with among all integer types that have at least the specified width.
2 The typedef name int_fastN_t designates the fastest signed integer type with a width</description>
    </item>
    
    <item>
      <title>『note』目前的vim</title>
      <link>https://daichou.github.io/posts/notevim/</link>
      <pubDate>Wed, 28 Sep 2016 23:16:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/notevim/</guid>
      <description>『note』目前的vim 本文僅僅紀錄我用了什麼vim plugin。
首先.vimrc
https://github.com/Daichou/environment/blob/master/.vimrc
  基本設定  set shiftwidth=4 set expandtab set softtabstop=4 set laststatus=2 set noshowmode set number set modeline set t\_Co=256 set tabstop=2 set fileencodings=utf-8,big5 set cursorline set mouse=a syntax on   編譯快捷鍵  autocmd filetype python nnoremap :w exec &amp;#39;!python &amp;#39;.shellescape(&amp;#39;%&amp;#39;) autocmd filetype c nnoremap :w exec &amp;#39;!clear&amp;amp;&amp;amp;gcc &amp;#39;.shellescape(&amp;#39;%&amp;#39;).&amp;#39; -o &amp;#39;.shellescape(&amp;#39;%:r&amp;#39;).&amp;#39;&amp;amp;&amp;amp;./&amp;#39;.shellescape(&amp;#39;%:r&amp;#39;) autocmd filetype cpp nnoremap :w exec &amp;#39;!clear;echo -n &amp;#34;====================&amp;#34;;TEMP=\`mktemp\`;script $TEMP -e -q -c &amp;#34;g++ &amp;#39;.</description>
    </item>
    
    <item>
      <title>John Murphy:特殊風格的電影配樂家</title>
      <link>https://daichou.github.io/posts/john-murphy/</link>
      <pubDate>Sat, 24 Sep 2016 08:55:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/john-murphy/</guid>
      <description>John Murphy:異軍突起的電影配樂家 首先先貼他的個人網站http://johnmurphyofficial.com/。
本文的音樂都在這：http://www.johnmurphyofficial.com/tunesbox_1.html
他最有名的三首配樂是『28天毀滅倒數(28 days later)』的『In the house,In the heartbeat』把活屍的壓迫感形容的很好，有興趣還可以聽聽看續集『28周毀滅倒數(28 weeks Later)』的開頭男主角的爸爸被追趕的那段，十分精彩，循環覆呇的節奏與逐漸加強的重音，就像一隻隻活屍在你身後快速的逼近你，即使你逃過當時，你有遠也不知道牆後是否還有另一隻在伺機而動。
第二首是同樣是Danny Boyle執導的『太陽浩劫(sunshine)』中的『Sunshine (Adagio in D Minor)』，這首曲子聽起來十分雄壯，有太陽的感覺。這首有名的點是她常出現在電影預告、商品廣告中，維基百科還有條目在統計他出現在那。包括Star Trek:Into Darkness、Kick Ass、X-men、The Adjustment Bureau還有Samsung的Smart TV廣告。其他運用這首的都在這https://en.wikipedia.org/wiki/Sunshine:_Music_from_the_Motion_Picture。
第三首是驚悚片：『左手邊的那棟房子』的配樂，不過這部電影我沒看過就不做評論了。</description>
    </item>
    
    <item>
      <title>[偷書賊]偷書賊與過於喧囂的孤獨</title>
      <link>https://daichou.github.io/posts/review-solitude/</link>
      <pubDate>Tue, 20 Sep 2016 08:21:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/review-solitude/</guid>
      <description>[偷書賊]偷書賊與過於喧囂的孤獨 偷書賊講述的是一個二戰時期一個德國小女孩靠著文字豐富自己心靈的故事，其中穿插著二戰時期生活環境的疲敝，還有人性的本質。
而赫拉巴爾的&amp;lt;過於喧囂的孤獨&amp;gt;則是以一個在廢紙回收廠的老員工，在工作之餘將書中知識收入自己的腦海，然而，其身處於社會的角落，還做著將書本壓成廢紙的工作，雖然學識涵養豐富，但作著一般人鄙視、無視的工作。其內心是過於喧囂的孤獨。
這兩本書一個是從剛識字的小孩角度看待文字的影響力，一個是從滿腹學識的老人在知識的翻騰中對比自身的孤獨感。同樣都是以文字的力量出發，但在人生起始階段與人生終老階段，文字以不同的方式影響著人們。
這兩本書都蠻推薦的(偷書賊較淺白)。</description>
    </item>
    
    <item>
      <title>在linux上製作win10 live USB</title>
      <link>https://daichou.github.io/posts/linuxwin10-live-usb/</link>
      <pubDate>Sat, 10 Sep 2016 20:22:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/linuxwin10-live-usb/</guid>
      <description>在linux上製作win10 live USB 這部份很簡單，只要記住一個重要的程式『winusb』，安裝這個程式，一切都簡單。
首先，以arch linux 為例，winusb是在aur裡，所以只要下：
$ yaourt -Sy winusb 即可安裝。
接著開始製作live usb，先找到win10 ISO 檔的路徑，還有你的隨身碟隨身碟掛載路徑，下以下指令：
$ winusb --install &amp;lt;iso path&amp;gt; &amp;lt;partition&amp;gt; 記得要用root or sudo來做。即可完成。</description>
    </item>
    
    <item>
      <title>快閃大對決：一場華爾街起義</title>
      <link>https://daichou.github.io/posts/review-flash-trade/</link>
      <pubDate>Fri, 09 Sep 2016 18:39:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/review-flash-trade/</guid>
      <description>快閃大對決：一場華爾街起義 我會找到這本書完全是因為這本書的作者是&amp;lt;魔球&amp;gt;、&amp;lt;攻其不備&amp;gt;、&amp;lt;大賣空&amp;gt;的作者，我蠻喜歡他的寫作風格。這本書算是他在台最新的(雖然是2014年的)。
***
這本書主要探討近年來美國股市興起的高頻交易如何危害市場，雖然我以前就有聽過『高頻交易』這個詞，但我沒想到它的實際運作方式這麼恐怖。美國現在有13個交易所交易所(還有60幾個暗池)之間彼此都有一些距離，有些在紐約，有些在芝加哥，即便現在通訊技術發達，但這些交易系統否此間的資訊仍有幾毫秒的差距，所以如果你能在資訊從一個交易所到另一個交易所之間提前買賣股票，就等於是在買樂透時提前知道結果然後進行下注。或者是在別人買股票前提前插隊將股票買走，然後用更高的價格賣回給買家。基本上所有交易操作都在毫秒內快速來回。這造成了股市成交量爆增、波動劇烈、還有快閃崩盤，在加上股票是一個趨近於零和的賽局，當有人在你買賣間先進行了一次交易，等於是從你身上扒了一層皮。
***
最後有群人為了打擊高頻交易，設計了一個慢市交易所(IEX)，讓所有交易都慢了330us而且個交易所的資訊到這個交易所的時間差都相同，使高頻交易失去套利空間，但這場與高頻交易間的戰爭仍在大股市間上演，高頻交易仍存在於市場。
***
現在的股票市場上冒出了一個新種族(bot)，這些程式在取代大量傳統交易員，在毫秒間改變市場走向，操縱著市場。
***
這不是Fintech什麼才是Fintech？(誤)</description>
    </item>
    
    <item>
      <title>Jekyll 一些問題解法</title>
      <link>https://daichou.github.io/posts/jekyll/</link>
      <pubDate>Wed, 31 Aug 2016 07:58:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/jekyll/</guid>
      <description>用github架Jekyll 一些問題解法 當一開始使用
$ jekyll serve 的時候，可能會遇到一些問題(其實是我遇到的啦)
jekyll serve not found 這是一個很好處理的問題，因爲你的~/.gem/ruby/{version}/bin資料夾沒有在$PATH路徑下。加上去就可解決了。
缺少bundler
kernel_require.rb:55:in `require&amp;#39;: cannot load such file -- bundler (LoadError) 大概的error如上。處理方式很簡單，就是安裝bundler。
$ gem install bundler 這樣就解決了。
如果還有以下錯誤：
resolver.rb:356:in `block in verify_gemfile_dependencies_are_found!&#39;: Could not find gem &amp;lsquo;jekyll-sitemap&amp;rsquo; in any of the gem sources listed in your Gemfile or available on this machine. (Bundler::GemNotFound)
則多下一行指令：
$ bundle install --path vendor/bundle invalid date &amp;hellip;YAML.. 跑jekyll serve的時候可能會有噴出一堆如下的錯誤。
Invalid date &amp;#39;&amp;lt;%= Time.now.strftime(&amp;#39;%Y-%m-%d %H:%M:%S %z&amp;#39;) %&amp;gt;&amp;#39;: Document &amp;#39;vendor/bundle/ruby/2.</description>
    </item>
    
    <item>
      <title>HackNTU2016小小心得</title>
      <link>https://daichou.github.io/posts/hackntu2016/</link>
      <pubDate>Wed, 24 Aug 2016 08:22:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/hackntu2016/</guid>
      <description>HackNTU2016小小心得 其實我本身已經去過去年(2015)的HackNTU了，所以這篇文章會稍微比較這兩年。HackNTU為台灣規模最大的hackthon，但其核心價值已經逐漸遠離黑客松的&amp;quot;合作&amp;rdquo;、&amp;ldquo;效率&amp;rdquo;、&amp;ldquo;有用&amp;rdquo;、&amp;ldquo;有趣&amp;quot;的精神了。hackNTU逐漸變成一種比賽，創業比賽。我個人認為有好有壞。好處讓hacker可以更有商業頭腦，除了設計搞怪小東西外，還可以走進市場，同時，由於評審來自商業界，有種吸引創投的fu。壞處當然就是過度商業化得黑客松已經變成創業松，一堆人拿早就跑很久的專案進來投，失去了黑客松該有的短期高效合作模式，另外過度傾向賺錢，偏離了其實這是一個技術性活動，一些不好的事情就這樣發生了:&amp;ldquo;簡報松&amp;rdquo;、&amp;ldquo;不會coding只做簡報拿獎&amp;rdquo;、&amp;ldquo;SetTimeout&amp;rdquo;。這樣失去了hacker們自我實現與實做的目標了。
今年由於受到COSCUP的撞期影響，人數大減3~4成，加上去年的風評不佳(評審問了『你怎麼賺錢』、『你怎麼make money』、『你的business model是什麼』)造成在社群間不好的名聲流傳。不過今年其實沒這個問題，評審都問一些本質與技術，這是一個好現象。可能因為人數大減的原因，使得今年食物較少(食物也是黑客松的精華阿)，肥宅我的心得試吃不飽。
今年贊助廠商變多，變得多元，不過兩排排了一排攤位，大投影牆還播著廣告，害我以為我來到世貿之類的地方了XD。</description>
    </item>
    
    <item>
      <title>[tools]GNU 開發工具：nm</title>
      <link>https://daichou.github.io/posts/toolsgnu-nm/</link>
      <pubDate>Tue, 16 Aug 2016 07:46:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/toolsgnu-nm/</guid>
      <description>[tools]GNU 開發工具：nm nm nm這東西是來列出object files(binary file)的符號(symbol)，包括列出地址(address)、類型、名稱。
以下我打了一個範例。
#include&amp;lt;stdio.h&amp;gt; void foo(){ printf(&amp;#34;bar&amp;#34;); } int Global_var; int Global_var_init = 0; int main() { int local_var; int local_var_init = 0; int a = local_var_init + Global_var_init; foo(); } 接下來是對其編譯出來的a.out下nm指令的結果。
0000000000601030 B __bss_start 0000000000601030 b completed.6916 0000000000601020 D __data_start 0000000000601020 W data_start 0000000000400430 t deregister_tm_clones 00000000004004b0 t __do_global_dtors_aux 0000000000600e10 t __do_global_dtors_aux_fini_array_entry 0000000000601028 D __dso_handle 0000000000600e20 d _DYNAMIC 0000000000601030 D _edata 0000000000601040 B _end 00000000004005b4 T _fini 00000000004004f6 T foo 00000000004004d0 t frame_dummy 0000000000600e08 t __frame_dummy_init_array_entry 0000000000400718 r __FRAME_END__ 0000000000601000 d _GLOBAL_OFFSET_TABLE_ 0000000000601038 B Global_var 0000000000601034 B Global_var_init w __gmon_start__ 00000000004005c8 r __GNU_EH_FRAME_HDR 00000000004003c8 T _init 0000000000600e10 t __init_array_end 0000000000600e08 t __init_array_start 00000000004005c0 R _IO_stdin_used 0000000000600e18 d __JCR_END__ 0000000000600e18 d __JCR_LIST__ 00000000004005b0 T __libc_csu_fini 0000000000400540 T __libc_csu_init U __libc_start_main@@GLIBC_2.</description>
    </item>
    
    <item>
      <title>用Compiler Explorer學習C/C&#43;&#43;的效能與實做</title>
      <link>https://daichou.github.io/posts/compiler-explorercc/</link>
      <pubDate>Tue, 16 Aug 2016 02:30:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/compiler-explorercc/</guid>
      <description>用Compiler Explorer學習C/C++的效能與實做 今天我發現一個網站:compiler explorer，這個網站可以將C和C++即時編譯為組語，而且寒可以選AT&amp;amp;T語法的nasm和INTEL語法的nasm，對於底層學習很有幫助。
支援 這個網站支援ARM、MIPS、X86、AVR等指令集的compiler，支援度甚廣，且網頁本身也開源(使用node.js)，連結:https://github.com/mattgodbolt/gcc-explorer
操作畫面</description>
    </item>
    
    <item>
      <title>使用Ardunio Atmega2560 連接 nRF24L01&#43;</title>
      <link>https://daichou.github.io/posts/ardunio-atmega2560-nrf24l01/</link>
      <pubDate>Fri, 05 Aug 2016 06:30:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/ardunio-atmega2560-nrf24l01/</guid>
      <description>使用Ardunio Atmega2560 連接 nRF24L01+ 關於library 目前主流有https://github.com/maniacbug/RF24與https://github.com/TMRh20/RF24這兩個。
其中TMRh20大大做的這個還可支援linux(Raspberry pi)，支援度較廣。不過本篇文章選用maniacbug大大的library。
mega2560連接nRF24L01 以下是nRF24L01 模組的照片與pinout。

從左上開始，右下結束。
         1.GND 2.VDD(3.6V以下)   3.CE 4.CSN   5.SCLK 6.MOSI   7.MISO 8.IRQ    Mega2560部份，我們不需要接IRQ，因為library沒有實做，讀者有興趣可以修改library中關於nRF24L01一個名叫config的暫存器，將mask中斷的部份歸零。
Mega2560的部份需要其上頭內建的SPI BUS，才能使用這個函式庫(TMRh20的library有提供Software SPI應用)。以下是Mega2560的SPI接腳對應。

SCK要接nRF24L01的SCLK，MOSI接MOSI，MISO接MISO，CE和CSN可自行定義腳位。
程式碼部份直接利用官往提供的example來做測試。
http://maniacbug.github.io/RF24/GettingStarted_8pde-example.html
原始碼中RF24物件建構子這行
RF24 radio(9,10); 9表示CE接腳，10表示CSN接腳。
程式運行時可以開啟Serial port monitor來觀察其運作，其中他在radio.printDetails();部份印出的細節可以多留意，尤其是收發兩端的address，在TX_ADDR那項兩邊要不同。接下來就可開心的看著她發送了。
連不上的一些解法 地址錯誤 兩邊的地址要可對到，一邊RX_ADDR要為另一邊TX_ADDR，這樣才可收到。
雜訊 有些nRF24L01模組的電源供應沒有電容濾波，可以自行用電容跨接GND和VCC兩端，建議選擇10uF到50uF的電容，另外模組的GND要和Ardunio的GND共地(從Ardunio直接拉GND是好選擇)。
傳輸速率過快 example預設為2Mbps，可自行降為1Mbps，有機會收到較佳的訊號。</description>
    </item>
    
    <item>
      <title>PWM產生方式</title>
      <link>https://daichou.github.io/posts/pwm/</link>
      <pubDate>Sun, 31 Jul 2016 02:22:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/pwm/</guid>
      <description>PWM簡述 PWM為Pulse Width Modulation的縮寫，對於只有high和low的數位訊號來說，如何用high,low比率調整出類似類比訊號為PWM的用處，另外大多數馬達也透過PWM來驅動轉速，LED由於只吃固定電壓，所以常用PWM來調整亮度。

duty cycle(占空比)為整個high時間除以週期時間(D = DT/T)。
PWM產生方式 PWM主要又三種方式產生：硬體內建PWM模組、中斷產生、迴圈。
硬體內建PWM模組 MCU內常內建PWM模組，以PIC系列為例，有CCP(Capture/Compare/PWM)模組、Output Compare模組和PWM模組。透過設定timer和暫存去達成PWM輸出。以下以dsPIC30F4013的Output Compare做示範。
#include &amp;lt;xc.h&amp;gt;  // FOSC #pragma config FOSFPR = XT_PLL4 // Oscillator (XT w/PLL 4x) #pragma config FCKSMEN = CSW_FSCM_OFF // Clock Switching and Monitor (Sw Disabled, Mon Disabled)  // FWDT #pragma config FWPSB = WDTPSB_16 // WDT Prescaler B (1:16) #pragma config FWPSA = WDTPSA_512 // WDT Prescaler A (1:512) #pragma config WDT = WDT_OFF // Watchdog Timer (Disabled)  // FBORPOR #pragma config FPWRT = PWRT_64 // POR Timer Value (64ms) #pragma config BODENV = BORV20 // Brown Out Voltage (Reserved) #pragma config BOREN = PBOR_ON // PBOR Enable (Enabled) #pragma config MCLRE = MCLR_EN // Master Clear Enable (Enabled)  // FGS #pragma config GWRP = GWRP_OFF // General Code Segment Write Protect (Disabled) #pragma config GCP = CODE_PROT_OFF // General Segment Code Protection (Disabled)  // FICD #pragma config ICS = ICS_PGD // Comm Channel Select (Use PGC/EMUC and PGD/EMUD)  #define Tcy 10000000 //10MHz oscillator with 4xPLL -&amp;gt; 10&amp;#39;000&amp;#39;000MIPS  //------------------------------------------------------------------------------ // main routine //------------------------------------------------------------------------------ int main(int argc, char** argv) { //------------------------------------------------------------------------------ // IO Plan  TRISA = 0x0000; TRISB = 0x0000; TRISC = 0x0000; TRISD = 0x0000; //RD1,RD2,RD3,RD4 -&amp;gt; PWM OC pin  TRISF = 0x0000; ADPCFG = 0xFFFF; //------------------------------------------------------------------------------ // initialize PWM  //PR2 = 50000; 1:256-&amp;gt; 200 HZ  PR2 = 25000; OC1RS = 1875; OC1CON = 0x0006; //Set PWM mode on OC1,Fault pin disable,Timer2 is source  OC2RS = 1875; OC2CON = 0x0006; //Set PWM mode on OC2,Fault pin disable,Timer2 is source  OC3RS = 1875; OC3CON = 0x0006; //Set PWM mode on OC3,Fault pin disable,Timer2 is source  OC4RS = 1875; OC4CON = 0x0006; //Set PWM mode on OC4,Fault pin disable,Timer2 is source  //IEC0bits.</description>
    </item>
    
    <item>
      <title>[筆記] libpqxx - prepare statements</title>
      <link>https://daichou.github.io/posts/libpqxx-prepare-statements/</link>
      <pubDate>Sun, 08 May 2016 09:16:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/libpqxx-prepare-statements/</guid>
      <description>prepare語法是現今SQL主要防止SQL injection的方法(另一種是字串處理)，prepare語法主要是限定SQL query語句中的變數，以防資料庫其他資料遭受破壞等。postgresSQL也有prepare語法。請見：http://www.postgresql.org/docs/9.1/static/sql-prepare.html
而libpqxx中也有prepare method。這個prepare框架一旦被定義後，它會存活於connetion物件存活期間(連線期間)。底下是範例，其中prepare_name爲使用者自定(case sensitive)，之後會用到。
connection C(/*user parameter*/); C.prepare(&amp;#34;prepare_name&amp;#34;,&amp;#34;SELECT NAME FROM TESTTABLE WHERE id = $1&amp;#34;); 再來是傳遞變數進入prepare的框架。
connection C(/*user parameter*/); pqxx::work W(C); C.prepare(&amp;#34;prepare_name&amp;#34;,&amp;#34;SELECT NAME FROM TESTTABLE WHERE id = $1&amp;#34;); pqxx::result r = W.prepared(&amp;#34;prepare_name&amp;#34;)(ID).exec(); W.commit(); 其中傳變數方法還有其他寫法，請見：http://stackoverflow.com/questions/31833322/how-to-prepare-statements-and-bind-parameters-in-postgresql-for-c
prepare方法有時會降低效率，其他細節都在官方paper中。</description>
    </item>
    
    <item>
      <title>Maker常用開發板</title>
      <link>https://daichou.github.io/posts/maker/</link>
      <pubDate>Sun, 01 May 2016 08:00:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/maker/</guid>
      <description>對於Maker來說，選擇適合的開發板可以加速make的時間。本文會依照難度特色來做分類。
入門款
** Ardunio系列：**
 基本款(Entry level):Ardunio UNO,Ardunio 101,Ardunio PRO  &amp;gt;&amp;raquo; 特色：pin腳少(少於20隻)，PWM port少(不多於6隻)，Analog輸入腳位少(少於6)。
&amp;gt;&amp;raquo; 適合入門玩家學習操作I/O(DigitalWrtie),PWM(AnalogWrite),ADC(analogRead)。適合小專案與空間較小之專案。
 進階板(Enhanced feature):Ardunio MEGA,Ardunio ZERO,Ardunio DUE  &amp;gt;&amp;raquo; Ardunio MEGA腳位很多，PWM腳多達15隻，對於需要大量馬達或servo的專案來說十分適合，而且其UART多達四組，還有一組SPI和一組I2C可方便擴充。
&amp;gt;&amp;raquo; Ardunio ZERO是小型低電壓板Ardunio。
&amp;gt;&amp;raquo; Ardunio DUE 是ARM-based的Ardunio，腳位很多，同時還有兩個DAC，和USB-OTG，為MEGA板所沒有的。
 IOT板：Ardunio YUN  &amp;gt;&amp;raquo;Ardunio YUN是一塊同時擁有MCU(Ardunio)和SOC(OS為linux)的開發板，基本連網功能透過linux部份，其餘操作在Ardunio部份上，可支援wifi(IEEE 802.11b/g/n)和ethernet(IEEE 802.11b/g/n)，想當然爾，當然是一塊面向物連網的開發板。
 其他module  很多，去找吧，我把他們全都放在那了。對於入門者來說，最重要的是有library和API支援，不然自己看datasheet來刻是很困難的。
 其他類Ardunio開發板  這裏指得是支援Ardunio語法(library)的開發板，常見的如Picdunio,linkit Smart 7688和linkit 7688 DUO系列等。
進階款
** Raspberry Pi**
 Pi 1,Pi 2 Pi3 , Pi zero:  基本上都是使用Broadcom的單板電腦，都是ARM以處理器為核心，當然ARM系列的優點都有(如省電)，支援USB、ethernet、RCA、I2S、SD卡、相機模組。
作業系統有Raspbian(Debian系，論壇資源最多，問題易找到解答)、Arch Linux Arm(Arch linux十分輕量，而且十分先進，其套件管理佳，但難度叫高)、OpenELEC、Pidora(Fedora)等。</description>
    </item>
    
    <item>
      <title>libpqxx - postgresql c&#43;&#43; library 基本教學</title>
      <link>https://daichou.github.io/posts/libpqxx-postgresql-c-library/</link>
      <pubDate>Sun, 01 May 2016 02:33:00 -0700</pubDate>
      
      <guid>https://daichou.github.io/posts/libpqxx-postgresql-c-library/</guid>
      <description>簡介  libpqxx是postgrsql 官方所推出的函式庫，基本上包裝得很好，用起來十分簡便。
libpqxx官網：http://pqxx.org/
 linux上安裝方式  請先安裝postgresql，方便起見可安裝php,phppgadmin和apache以利測試。
link:https://wiki.archlinux.org/index.php/PostgreSQL
libray link:http://pqxx.org/download/software/libpqxx/
$ wget http://pqxx.org/download/software/libpqxx/libpqxx-4.0.tar.gz $ tar -zxvf libpqxx-4.0-tar.gz $ cd libpqxx-4.0 $ ./configure $ make $ make install arch linux上安裝方式，libpqxx為Extra package。
link:https://www.archlinux.org/packages/extra/i686/libpqxx/
$ sudo pacman -Sy libpqxx 安裝完成後，於postgresql安裝目錄下。
$ cp pg_hba.conf.sample pg_hba.conf 於pg_hba.conf新增
# IPv4 local connections: host all all 127.0.0.1/32 md5 啟動與停止postgresql，基本上使用systemd的linux distro都可用以下方式來處理
$ sudo systemctl start postgresql.service $ sudo systemctl stop postgresql.service  基本用法  libpqxx通常需要透過pqxx::connection來建立連線，接著以transaction物件pqxx::work執行sql操作。以下為基本範例</description>
    </item>
    
  </channel>
</rss>